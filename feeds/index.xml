<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>85后那些年</title><link href="http://xiangyuan.github.io/" rel="alternate"></link><link href="http://xiangyuan.github.io/feeds/index.xml" rel="self"></link><id>http://xiangyuan.github.io/</id><updated>2014-01-25T16:32:00+08:00</updated><entry><title>检查ios应用中是否有存在没有使用过的图片资源文件</title><link href="http://xiangyuan.github.io/posts/2014/01/25/jian-cha-iosying-yong-zhong-shi-fou-you-cun-zai-mei-you-shi-yong-guo-de-tu-pian-zi-yuan-wen-jian/" rel="alternate"></link><updated>2014-01-25T16:32:00+08:00</updated><author><name>xiangyuan</name></author><id>tag:xiangyuan.github.io,2014-01-25:posts/2014/01/25/jian-cha-iosying-yong-zhong-shi-fou-you-cun-zai-mei-you-shi-yong-guo-de-tu-pian-zi-yuan-wen-jian/</id><summary type="html">&lt;p&gt;我在开发ios应用的时候，会添加很多图片资源文件进去，更多时候当是多人协作时，添加的图片资源有些可能会没有使用的到，然而被我们忽略了。&lt;/p&gt;
&lt;p&gt;然后我就用python写了一个脚本文件去查换一些没有使用的资源图片。在开始之前让我们先了解一下ack命令工具。&lt;/p&gt;
&lt;div class="section" id="ack"&gt;
&lt;h2&gt;ack 是一个非常高效的查换工具&lt;/h2&gt;
&lt;p&gt;可以查找文件中哪些地方使用了一些特殊指定的字符串
比如&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ack -i 'about'
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="install-ack-on-osx"&gt;
&lt;h2&gt;Install ack on OSX&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
brew install ack
&lt;/pre&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;find命令查找出所有图片&lt;/li&gt;
&lt;li&gt;ack命令处理&lt;/li&gt;
&lt;li&gt;得出所有的无用图片资源文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="literal-block"&gt;
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# find no use image files
#
import os
import subprocess
# import shlex
import pprint
import glob

path = '.'
bundle = ''

try:
   f = glob.glob('*.xcodeproj')
   if not f:
           print &amp;quot;can't find the xcode project&amp;quot;
                   exit(1)
                       else:
                               fname = f[0]
                                       name, ext = os.path.splitext(fname)
                                               path = path + os.path.sep + name
                                               except:
                                                   exit(1)
                                                   # root = os.path.expanduser(path)
                                                   os.chdir(path)
                                                   print os.getcwd()

                                                   # files = os.listdir(root)
                                                   # print files
                                                   result = []
                                                   try:
                                                       command = 'find . -name &amp;quot;*.png&amp;quot; -or -name &amp;quot;*.jpg&amp;quot; -or -name &amp;quot;*.gif&amp;quot; -or -name &amp;quot;*.jpeg&amp;quot;'
                                                           r = subprocess.check_output(command, shell=True)
                                                               lines = r.split('\n')
                                                                   for line in lines:
                                                                           fname = os.path.basename(line)
                                                                                   c = fname.count('&amp;#64;')
                                                                                           if c &amp;gt; 0:
                                                                                                       name, _ = fname.split('&amp;#64;')
                                                                                                               else:
                                                                                                                           name, ext = os.path.splitext(fname)
                                                                                                                                   if name != '':
                                                                                                                                               if not bundle:
                                                                                                                                                               target = name
                                                                                                                                                                           else:
                                                                                                                                                                                           target = ''.join((bundle, name))
                                                                                                                                                                                                       print target
                                                                                                                                                                                                                   cmd = '/usr/local/bin/ack -i &amp;quot;%s&amp;quot;' % target
                                                                                                                                                                                                                               c = subprocess.call(cmd, shell=True)
                                                                                                                                                                                                                                           # p = subprocess.Popen(cmd, shell=True)
                                                                                                                                                                                                                                                       # o, e = p.communicate()
                                                                                                                                                                                                                                                                   if c == 1:
                                                                                                                                                                                                                                                                                   result.append(target)
                                                                                                                                                                                                                                                                                   except:
                                                                                                                                                                                                                                                                                       raise

                                                                                                                                                                                                                                                                                       print(&amp;quot;===================\n&amp;quot;)
                                                                                                                                                                                                                                                                                       print(&amp;quot;no used files&amp;quot;)
                                                                                                                                                                                                                                                                                       pprint.pprint(result)
&lt;/pre&gt;
&lt;/div&gt;
</summary><category term="python"></category><category term="ios"></category></entry><entry><title>那条线</title><link href="http://xiangyuan.github.io/posts/2014/01/14/na-tiao-xian/" rel="alternate"></link><updated>2014-01-14T22:57:00+08:00</updated><author><name>xiangyuan</name></author><id>tag:xiangyuan.github.io,2014-01-14:posts/2014/01/14/na-tiao-xian/</id><summary type="html">&lt;p&gt;看不懂  或许不是遥远，&lt;/p&gt;
&lt;p&gt;就是你我之间。&lt;/p&gt;
&lt;p&gt;有着那一条线，&lt;/p&gt;
&lt;p&gt;那么多路口，那么多转弯&lt;/p&gt;
&lt;p&gt;看不见，或是许多想念，&lt;/p&gt;
&lt;p&gt;就是你我之间。&lt;/p&gt;
&lt;p&gt;有着那一条线，&lt;/p&gt;
&lt;p&gt;有过些许，有过转念。&lt;/p&gt;
&lt;p&gt;踮脚张望已旧的嚣张，&lt;/p&gt;
&lt;p&gt;心却依旧彷徨。&lt;/p&gt;
&lt;p&gt;那条线,&lt;/p&gt;
&lt;p&gt;平行了过往。&lt;/p&gt;
</summary><category term="情感"></category></entry><entry><title>controller互加20像素下移问题</title><link href="http://xiangyuan.github.io/posts/2013/06/03/controllerhu-jia-20xiang-su-xia-yi-wen-ti/" rel="alternate"></link><updated>2013-06-03T23:05:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2013-06-03:posts/2013/06/03/controllerhu-jia-20xiang-su-xia-yi-wen-ti/</id><summary type="html">&lt;pre class="literal-block"&gt;
CGRect frame = self.view.bounds;
NSLog(&amp;#64;&amp;quot;%f %f %f %f&amp;quot;,frame.origin.x,frame.origin.y,frame.size.width,frame.size.height);
self.view.bounds = [UIScreen mainScreen].bounds;
NSLog(&amp;#64;&amp;quot;%f %f %f %f&amp;quot;,frame.origin.x,frame.origin.y,frame.size.width,frame.size.height);
[self.view addSubview:_tabBarController.view];
&lt;/pre&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;uitabbarcontroller被添加到另一个controller里面时，会出现一个20高度的空白，也就是&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;会引起整个视图向底部移动。&lt;/div&gt;
&lt;div class="line"&gt;需要添加self.view.bounds = [UIScreen mainScreen].bounds; 就可以解决。&lt;/div&gt;
&lt;div class="line"&gt;原因是两种情况依赖的父对象不同。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;##
上面在ios7已有问题，不能再使用，可使用其他方式解决。&lt;/p&gt;
</summary></entry><entry><title>一个抽拉界面菜单实现</title><link href="http://xiangyuan.github.io/posts/2013/05/01/ge-chou-la-jie-mian-cai-dan-shi-xian/" rel="alternate"></link><updated>2013-05-01T15:38:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2013-05-01:posts/2013/05/01/ge-chou-la-jie-mian-cai-dan-shi-xian/</id><summary type="html">&lt;p&gt;在一个叫作群群的应用中，有一个效果。某一个按钮进行接动（pan）时，就会动态的出来一个菜单。&lt;/p&gt;
&lt;p&gt;然后发了一些时间作了一个实现。方案觉得还不怎地好。图片版权归群群应用所有。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;实现效果如下图：&lt;/div&gt;
&lt;/div&gt;
&lt;img alt="screen shot" src="/images/Screenshot-2013.05.01-15.13.35.png" style="width: 200px; height: 300px;" /&gt;
&lt;img alt="screen shot" src="/images/Screenshot-2013.05.01-15.13.39.png" style="width: 200px; height: 300px;" /&gt;
&lt;img alt="screen shot" src="/images/Screenshot-2013.05.01-15.13.43.png" style="width: 200px; height: 300px;" /&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;原理是&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;1、图片处理。&lt;/div&gt;
&lt;div class="line"&gt;2、pan手势。&lt;/div&gt;
&lt;div class="line"&gt;3、frame调整。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary></entry><entry><title>ios上可拖动的滚动条</title><link href="http://xiangyuan.github.io/posts/2013/04/27/iosshang-ke-tuo-dong-de-gun-dong-tiao/" rel="alternate"></link><updated>2013-04-27T18:13:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2013-04-27:posts/2013/04/27/iosshang-ke-tuo-dong-de-gun-dong-tiao/</id><summary type="html">&lt;p&gt;在android平台中listview有一个thumb手机样式的拖动条，可以快速的拖动列表。&lt;/p&gt;
&lt;p&gt;在ios上这个却是没有的。&lt;/p&gt;
&lt;p&gt;在进行之前先来看一个场景，很多ios应用在看列表时，都会动态加载更多，然后随着列表项越来越多时。再到最上面时滚动就比较的费时，读一些内容软多的文字时也会碰到这种情况。&lt;/p&gt;
&lt;p&gt;zaker上面看文章时也会一个快速拖动条，看新闻体验就比较的好。&lt;/p&gt;
&lt;p&gt;这个手机样式图下图。&lt;/p&gt;
&lt;img alt="thumb imageview" src="/images/1AB64F7B-B686-4A71-AAF6-037E80C6C39F.png" style="width: 200px; height: 300px;" /&gt;
&lt;p&gt;当然上图中的手指并不是图，是通过代码实现的。上面是table做的测试。下面是一个scrollview结果的图形。&lt;/p&gt;
&lt;img alt="thumb imageview" src="/images/9271739A-005A-41F3-9C2A-ACA3E189D62E.png" style="width: 200px; height: 300px;" /&gt;
&lt;p&gt;一、下面先说说那个手指样式类图实现原理。&lt;/p&gt;
&lt;p&gt;手指图是上下都是一个三角形，通过path画一个三角形，然后将图形context反转再画一个三角。&lt;/p&gt;
&lt;p&gt;中间部分是一个pattern模式图形.&lt;/p&gt;
&lt;p&gt;画三角&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/**
    *  /\
    ** --
    *  | |
    *  \/
    */
   CGRect bounds = self.bounds;
   CGMutablePathRef pathref = CGPathCreateMutable();
   CGContextSaveGState(ctx);
   CGContextSetLineWidth(ctx, 2);
   CGContextSetFillColorWithColor(ctx, [UIColor grayColor].CGColor);
   CGPathMoveToPoint(pathref, NULL, bounds.origin.x + bounds.size.width / 2, 0.f);
   CGPathAddLineToPoint(pathref, NULL, 0.f, kTriangleHeight);
   CGPathAddLineToPoint(pathref, NULL, bounds.size.width, kTriangleHeight);
   CGPathCloseSubpath(pathref);
   CGContextAddPath(ctx, pathref);
   CGContextDrawPath(ctx, kCGPathFill);
   CGContextRestoreGState(ctx);

   CGContextSaveGState(ctx);
   CGContextTranslateCTM(ctx, 0.f, bounds.size.height);
   CGContextScaleCTM(ctx, 1.f, -1);
   CGContextSetLineWidth(ctx, 2);
   CGContextSetFillColorWithColor(ctx, [UIColor grayColor].CGColor);
   CGContextAddPath(ctx, pathref);
   CGContextDrawPath(ctx, kCGPathFill);
   CGContextRestoreGState(ctx);
   CGPathRelease(pathref);
&lt;/pre&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;2、模式画图&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;1.创建pattern&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;pre class="literal-block"&gt;
CGPatternRef CGPatternCreate (
void *info,//传递给画图回调函数的参数
CGRect bounds,//每一个单元格的大小，上图里面就是一个小圆
CGAffineTransform matrix,//变换矩阵
CGFloat xStep,//画完一个格后，x轴偏移
CGFloat yStep,
CGPatternTiling tiling,
bool isColored,
const CGPatternCallbacks *callbacks//画图回调
 );
&lt;/pre&gt;
&lt;p&gt;2.完整代码&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static const CGPatternCallbacks callbacks = { 0, &amp;amp;drawCellCallback, NULL };

    CGPatternRef pattern = CGPatternCreate(0, CGRectMake(0.0, 0.0, 6, 6), CGAffineTransformIdentity, 5, 7, kCGPatternTilingConstantSpacing, true, &amp;amp;callbacks);
    CGContextSetFillPattern(ctx, pattern, α);
    CGPatternRelease(pattern);
    CGContextFillRect(ctx, CGRectMake(2.f, kTriangleHeight + 4, bounds.size.width - 4, bounds.size.height - 2 * kTriangleHeight - 8));
    CGContextRestoreGState(ctx);
&lt;/pre&gt;
&lt;p&gt;二、然后就是实现触摸滚动了。&lt;/p&gt;
</summary></entry><entry><title>HLS之ts文件格式分析</title><link href="http://xiangyuan.github.io/posts/2013/04/26/hlszhi-tswen-jian-ge-shi-fen-xi/" rel="alternate"></link><updated>2013-04-26T18:06:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2013-04-26:posts/2013/04/26/hlszhi-tswen-jian-ge-shi-fen-xi/</id><summary type="html">&lt;p&gt;HTTP Live Streaming（HLS）是苹果公司(Apple
Inc.)实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播，主要应用在iOS系统，为iOS设备（如iPhone、iPad）提供音视频直播和点播方案。HLS点播，基本上就是常见的分段HTTP点播，不同在于，它的分段非常小。&lt;/p&gt;
&lt;p&gt;相对于常见的流媒体直播协议，例如RTMP协议、RTSP协议、MMS协议等，HLS直播最大的不同在于，直播客户端获取到的，并不是一个完整的数据流。HLS协议在服务器端将直播数据流存储为连续的、很短时长的媒体文件（MPEG-TS格式），而客户端则不断的下载并播放这些小文件，因为服务器端总是会将最新的直播数据生成新的小文件，这样客户端只要不停的按顺序播放从服务器获取到的文件，就实现了直播。由此可见，基本上可以认为，HLS是以点播的技术方式来实现直播。由于数据通过HTTP协议传输，所以完全不用考虑防火墙或者代理的问题，而且分段文件的时长很短，客户端可以很快的选择和切换码率，以适应不同带宽条件下的播放。不过HLS的这种技术特点，决定了它的延迟一般总是会高于普通的流媒体直播协议。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;根据以上的了解要实现HTTP Live Streaming直播，需要研究并实现以下技术关键点&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;/*&lt;/div&gt;
&lt;div class="line"&gt;采集视频源和音频源的数据&lt;/div&gt;
&lt;div class="line"&gt;对原始数据进行H264编码和AAC编码&lt;/div&gt;
&lt;div class="line"&gt;视频和音频数据封装为MPEG-TS包&lt;/div&gt;
&lt;div class="line"&gt;HLS分段生成策略及m3u8索引文件&lt;/div&gt;
&lt;div class="line"&gt;HTTP传输协议&lt;/div&gt;
&lt;div class="line"&gt;*/&lt;/div&gt;
&lt;div class="line"&gt;本文介绍对ts文件的分析。一个ts大体结构如下&lt;/div&gt;
&lt;div class="line"&gt;+＝pid-----------pid------------------&amp;gt;pid&lt;/div&gt;
&lt;div class="line"&gt;| &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;/div&gt;
&lt;div class="line"&gt;| &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;| &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;|&lt;/div&gt;
&lt;div class="line"&gt;ts-packet &amp;nbsp; ts-packet &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ts-packet&lt;/div&gt;
&lt;div class="line"&gt;|&lt;/div&gt;
&lt;div class="line"&gt;|&lt;/div&gt;
&lt;div class="line"&gt;ts-packet ...&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;ts-packet:一般为固定188字节 ts-packet--|---ts_packet_header&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;|&lt;/div&gt;
&lt;div class="line"&gt;|---pes_header(如果存在的话)&lt;/div&gt;
&lt;div class="line"&gt;|&lt;/div&gt;
&lt;div class="line"&gt;|----数据区&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;另外一些比较重要的是pat与pmt，在此不作介绍，&lt;a class="reference external" href="http://mumudvb.braice.net/mumudrupal/sites/default/files/iso13818-1.pdf"&gt;参看ISO文档&lt;/a&gt;&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;代码解析原理；&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;1、188字节读取&lt;/div&gt;
&lt;div class="line"&gt;2、分析ts_header信息。&lt;/div&gt;
&lt;div class="line"&gt;3、去掉ts_header长度，接着分析pes包信息（如果存在）&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;我的c简单操作部分代码，希望你加入完整。&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;a class="reference external" href="https://github.com/xiangyuan/tsconstruct"&gt;https://github.com/xiangyuan/tsconstruct&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;接着要做的一件事情是将h264帧构造成ts格式流。&lt;/p&gt;
</summary></entry><entry><title>UIColor设置背景和UIImage图片拉伸</title><link href="http://xiangyuan.github.io/posts/2013/04/15/uicolorshe-zhi-bei-jing-he-uiimagetu-pian-la-shen/" rel="alternate"></link><updated>2013-04-15T11:21:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2013-04-15:posts/2013/04/15/uicolorshe-zhi-bei-jing-he-uiimagetu-pian-la-shen/</id><summary type="html">&lt;div class="section" id="uicolor"&gt;
&lt;h2&gt;&lt;strong&gt;①：UIColor设置背景&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;通常我们在设置一个view的背景为一个图片的时候，我们往往在上面加上一个imageview，然后在imageview中添加图片作为背景，&lt;/p&gt;
&lt;p&gt;那如果app中要求的背景是一个草坪的图形，是不是我们就必须画一个和手机屏幕一样打的草坪的图片呢，其实没有必要，我们只需要一个小小的草坪的图片，然后让它在背景上面重复平铺就可以了。&lt;/p&gt;
&lt;p&gt;首先，准备一个草坪的图片&lt;a class="reference external" href="http://kingiol.com/bl/wp-content/uploads/2013/04/bg.png"&gt;&lt;img alt="草坪" src="http://kingiol.com/bl/wp-content/uploads/2013/04/bg.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后我们就用这张图片在来填充这个屏幕的背景&lt;/p&gt;
&lt;pre class="literal-block"&gt;
UIImage *bgImage = [UIImage imageNamed:&amp;#64;&amp;quot;bg.png&amp;quot;];
self.view.backgroundColor = [UIColor colorWithPatternImage:bgImage];
&lt;/pre&gt;
&lt;p&gt;然后运行app，查看屏幕中的背景变化：&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://kingiol.com/bl/wp-content/uploads/2013/04/QQ20130415-3.png"&gt;&lt;img alt="image1" src="http://kingiol.com/bl/wp-content/uploads/2013/04/QQ20130415-3-154x300.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="uiimage"&gt;
&lt;h2&gt;&lt;strong&gt;②：UIImage图片拉伸&lt;/strong&gt;&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
UIImage *imageViewBg = [bgImage resizableImageWithCapInsets:UIEdgeInsetsMake(50, 50, 50, 50)];
&lt;/pre&gt;
&lt;p&gt;用此方法可以实现。边框区域不会拉伸，保持原样。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://kingiol.com/bl/wp-content/uploads/2013/04/imageResize.png"&gt;&lt;img alt="image2" src="http://kingiol.com/bl/wp-content/uploads/2013/04/imageResize-300x241.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</summary></entry><entry><title>opengles20之二</title><link href="http://xiangyuan.github.io/posts/2013/04/09/opengles20zhi-er/" rel="alternate"></link><updated>2013-04-09T22:33:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2013-04-09:posts/2013/04/09/opengles20zhi-er/</id><summary type="html">&lt;p&gt;关于上一篇写一个demo的，具地代码地址如下。有空再细细描述&lt;/p&gt;
&lt;p&gt;我的github地址：&lt;a class="reference external" href="https://github.com/xiangyuan/gles20demo.git"&gt;https://github.com/xiangyuan/gles20demo.git&lt;/a&gt;&lt;/p&gt;
</summary></entry><entry><title>Removing NSLogs for distribution</title><link href="http://xiangyuan.github.io/posts/2013/04/01/removing-nslogs-for-distribution/" rel="alternate"></link><updated>2013-04-01T15:36:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2013-04-01:posts/2013/04/01/removing-nslogs-for-distribution/</id><summary type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;在开发iOS应用时经常使用NSLog打印信息来调试，但在发布时这些打印信息应该去除,逐个的去注释掉打印语句太过麻烦，可以使用预处理宏在发布app时去掉打印，方法如下:&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;在每个工程里都有一个-Prefix.pch文件,在此文件中添加如下语句&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;#if DEBUG&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;#warning NSLogs will be shown&lt;/div&gt;
&lt;div class="line"&gt;#else&lt;/div&gt;
&lt;div class="line"&gt;#define NSLog(...) {}&lt;/div&gt;
&lt;div class="line"&gt;#endif&lt;/div&gt;
&lt;div class="line"&gt;这样，在开发时会有NSLogs will be&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2013/removing-nslogs-for-distribution.rst&lt;/tt&gt;, line 11)&lt;/p&gt;
Line block ends without a blank line.&lt;/div&gt;
&lt;p&gt;shown的告警，此时NSLog打印可以正常显示；在发布时NSLog被定义为空语句，不打印任何数据。&lt;/p&gt;
</summary></entry><entry><title>纷繁</title><link href="http://xiangyuan.github.io/posts/2013/03/22/fen-fan/" rel="alternate"></link><updated>2013-03-22T17:07:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2013-03-22:posts/2013/03/22/fen-fan/</id><summary type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;突然觉得人的一生非常短暂，而且人与人之间的差距。或是贫穷、或是富有，每个人都有自己要去做的一些事情。然而纷繁复杂的社会使那偶尔清静的一隅渐渐消逝。使得我们放下了好多曾经放在心上的事情也慢慢的被我们遗忘。&lt;/div&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2013/emotion_feng_fan.rst&lt;/tt&gt;, line 8)&lt;/p&gt;
Line block ends without a blank line.&lt;/div&gt;
&lt;p&gt;身边多了新的朋友、新的牵挂、新的责任，也让我们变得不知所挫。而且我相信人的一生说不定哪天就没有了，有很多的不平，很多的放不下在岁月中慢慢变淡。从而又进入了一个新的起点。
|
做一些没有做的事情就变得必要了，曾经自己觉得以后我们可以改变很多人，帮助很多人。岁月如河，随着时间的向前推移，那些让自己觉得是己任的东西太多被我们放下了。虽然我们不能改变世界，但我们可以改变自己。今天开始想做的事情一定去一件件的做完，就当作是死前的那种必要性的东西去看待。
|
没有人会在意你的不存在，因为或是没有被别人放在心上，或是被时间给冲淡。就像鲁迅一样有多少还记得这个模眉冷对千夫指，俯者甘为孺子牛的他，他就这样被我们给遗忘在历史的长河之中，就做些对他人有意义的事情吧，因为自己能改变的太少了。
|  今天开始好好对待身边的每一个人，there are so many things i can’t to
let you know,because i love you 。
虽然你们不一定在乎我是谁，我要把一些事情给做到吧，因为哪天我会不在的，你们过的好就行。不求闻达于诸侯，但求放在心上。&lt;/p&gt;
</summary></entry><entry><title>关于图象mask与blend实现之一</title><link href="http://xiangyuan.github.io/posts/2013/03/22/guan-yu-tu-xiang-maskyu-blendshi-xian-zhi/" rel="alternate"></link><updated>2013-03-22T17:05:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2013-03-22:posts/2013/03/22/guan-yu-tu-xiang-maskyu-blendshi-xian-zhi/</id><summary type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;1、关于使用 CGImageCreateWithMask(&amp;lt;#CGImageRef image#&amp;gt;, &amp;lt;#CGImageRefmask#&amp;gt;)来进行|| 掩码时。&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;情况一：第二个参数是用CGImageMaskCreate创建生成的 image mask。&lt;/div&gt;
&lt;div class="line"&gt;那么就会是黑色部分出现，白色部分消失。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;pre class="literal-block"&gt;
CGImageRef topRef = mask.CGImage;
CGImageRef maskImage = CGImageMaskCreate(CGImageGetWidth(topRef),
CGImageGetHeight(topRef), CGImageGetBitsPerComponent(topRef),
CGImageGetBitsPerPixel(topRef), CGImageGetBytesPerRow(topRef),
CGImageGetDataProvider(topRef), CGImageGetDecode(topRef), false);
// CGImageRef target = CGImageCreateWithMask(origin.CGImage,maskImage);
// UIImage \* image = [UIImage imageWithCGImage:target];

//release
CGImageRelease(maskImage);
&lt;/pre&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;情况二：第二个参数是用cgimagecreate创建生成的一个image对象时，&lt;/div&gt;
&lt;div class="line"&gt;那么就会和情况一产生相反的结果。多半可能会不显示.&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;注意：外部图片不能直接用来作为mask的图像。&lt;/p&gt;
&lt;p&gt;2、色彩来做为Mask&lt;/p&gt;
&lt;p&gt;3、context clip来实现Mask&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;使用两个图片实现圆角图形&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;如下代码&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;pre class="literal-block"&gt;
UIImage \*background = [UIImage imageNamed:&amp;#64;&amp;quot;logo\_back&amp;quot;];
UIImage \*front = [UIImage imageNamed:&amp;#64;&amp;quot;profile&amp;quot;];

CGContextRef context = UIGraphicsGetCurrentContext();
CGContextSaveGState(context);
CGContextSetBlendMode(context, kCGBlendModeDarken);
CGRect size = CGRectMake(0.f, 0.f, background.size.width,background.size.height);
[background drawAtPoint:CGPointMake(0.f, 0.f)];
CGContextTranslateCTM(context, 0.f, background.size.height);
CGContextScaleCTM(context, 1.f, -1);
CGContextDrawImage(context, size, front.CGImage);
CGContextRestoreGState(context);
&lt;/pre&gt;
</summary></entry><entry><title>ios项目中c++头文件找不到错误</title><link href="http://xiangyuan.github.io/posts/2013/03/05/iosxiang-mu-zhong-ctou-wen-jian-zhao-bu-dao-cuo-wu/" rel="alternate"></link><updated>2013-03-05T14:09:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2013-03-05:posts/2013/03/05/iosxiang-mu-zhong-ctou-wen-jian-zhao-bu-dao-cuo-wu/</id><summary type="html">&lt;p&gt;我们知道object-c与c++代码混合使用时，会将文件改为.mm的后缀。这个xcode在编译时就会使用clang和llvmg++来编译，一些标准备库文件就会正常识别。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;但是出现了另外一问题。在.h的文件里面使用了c++的库文件时，却引起了not&lt;/div&gt;
&lt;/div&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2013/ios_cplusplus_header.rst&lt;/tt&gt;, line 10)&lt;/p&gt;
Line block ends without a blank line.&lt;/div&gt;
&lt;p&gt;found 编译错误。
|  解决办法如下：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#include
#ifdef __cplusplus
#include
#include
#include
#include
#include
#include
#endif

#ifdef __OBJC__
#warning import some object c header file
#endif
&lt;/pre&gt;
</summary></entry><entry><title>ImageIO介绍</title><link href="http://xiangyuan.github.io/posts/2013/02/25/imageiojie-shao/" rel="alternate"></link><updated>2013-02-25T19:18:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2013-02-25:posts/2013/02/25/imageiojie-shao/</id><summary type="html">&lt;p&gt;Image IO允许应用程序读写大部分图片文件格式。起初是作为Core Graphics
框架的一部分，后来独立出来，允许开发者操作图像数据且非常高效。读取图片属性，提供颜色管理。（此接口osx
v10.4 ios4.0）&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Image I/O框架的特点：&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;1、mac平台最快的图像编码解码操作。&lt;/div&gt;
&lt;div class="line"&gt;2、渐增的图片加载方式。&lt;/div&gt;
&lt;div class="line"&gt;3、图片metadata信息的访问（ios不支持）。&lt;/div&gt;
&lt;div class="line"&gt;4、有效的缓存。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;下面是访问图片的exif等信息的事例操作。当然还可以通过asset
library去操作。&lt;a class="reference external" href="https://developer.apple.com/library/ios/#documentation/AssetsLibrary/Reference/ALAsset_Class/Reference/Reference.html"&gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过io框架操作代码如下&lt;/p&gt;
&lt;pre class="literal-block"&gt;
//1.create the image source
    NSURL * imageURL = [[NSBundle mainBundle] URLForImageResource:&amp;#64;&amp;quot;test_img.JPG&amp;quot;];

    CFDictionaryRef myOptions = NULL;

    CFStringRef myKeys[2];
    myKeys[0] = kCGImageSourceShouldCache;
    myKeys[1] = kCGImageSourceShouldAllowFloat;

    CFStringRef myValues[2];
    myValues[0] = (CFTypeRef)kCFBooleanTrue;
    myValues[1] = (CFTypeRef)kCFBooleanTrue;
//    NSDictionary * options = [NSDictionary dictionaryWithObjectsAndKeys:kCFBooleanTrue,kCGImageSourceShouldCache,kCFBooleanTrue,kCGImageSourceShouldAllowFloat, nil];

    myOptions = CFDictionaryCreate(NULL, (const void **)myKeys, (const void**)myValues, 2, &amp;amp;kCFTypeDictionaryKeyCallBacks, &amp;amp;kCFTypeDictionaryValueCallBacks);
    CGImageSourceRef imageSourceRef = CGImageSourceCreateWithURL((CFURLRef)imageURL, myOptions);
    CFRelease(myOptions);

    if (imageSourceRef == NULL) {
        NSLog(&amp;#64;&amp;quot;imagesource is NULL&amp;quot;);
    } else {
        // read the image meta data
        CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(imageSourceRef, 0, NULL);
//        CFDictionaryRef properties = CGImageSourceCopyProperties(imageSourceRef, nil);
        NSDictionary * dictionary = (NSDictionary*)properties;
        [dictionary enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
            NSLog(&amp;#64;&amp;quot;key = %&amp;#64; value = %&amp;#64;&amp;quot;,key,obj);
        }];

//        CGImageMetadataRef metaRef = CGImageSourceCopyMetadataAtIndex(imageSourceRef, 0, NULL);
//        CFArrayRef  metaTags = CGImageMetadataCopyTags(metaRef);
//        CFIndex len = CFArrayGetCount(metaTags);
//        for (int i = 0; i &amp;lt; len; i ++) {
//            CGImageMetadataTagRef tagRef = (CGImageMetadataTagRef)CFArrayGetValueAtIndex(metaTags, i);
//            NSLog(&amp;#64;&amp;quot;tag name =&amp;quot;,CGImageMetadataTagCopyName(tagRef),CGImageMetadataTagCopyValue(tagRef))
//        }
    }
&lt;/pre&gt;
&lt;p&gt;结果如下&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/*
 key = {TIFF} value = {
 DateTime = &amp;quot;2012:09:23 11:33:51&amp;quot;;
 ImageDescription = &amp;quot;                               &amp;quot;;
 Make = Canon;
 Model = &amp;quot;Canon IXUS 220HS&amp;quot;;
 Orientation = 1;
 ResolutionUnit = 2;
 XResolution = 180;
 YResolution = 180;
 }
 2013-02-25 17:31:22.261 ImageIODemo[2571:303] key = {Exif} value = {
 ApertureValue = &amp;quot;2.875&amp;quot;;
 ColorSpace = 1;
 ComponentsConfiguration =     (
 1,
 2,
 3,
 0
 );
 CompressedBitsPerPixel = 3;
 CustomRendered = 0;
 DateTimeDigitized = &amp;quot;2012:09:23 11:33:51&amp;quot;;
 DateTimeOriginal = &amp;quot;2012:09:23 11:33:51&amp;quot;;
 DigitalZoomRatio = 1;
 ExifVersion =     (
 2,
 3
 );
 ExposureBiasValue = 0;
 ExposureMode = 0;
 ExposureTime = &amp;quot;0.04&amp;quot;;
 FNumber = &amp;quot;2.7&amp;quot;;
 FileSource = 3;
 Flash = 16;
 FlashPixVersion =     (
 1,
 0
 );
 FocalLength = &amp;quot;4.3&amp;quot;;
 FocalPlaneResolutionUnit = 2;
 FocalPlaneXResolution = &amp;quot;11540.98360655738&amp;quot;;
 FocalPlaneYResolution = &amp;quot;11540.98360655738&amp;quot;;
 ISOSpeedRatings =     (
 800
 );
 MaxApertureValue = &amp;quot;2.875&amp;quot;;
 MeteringMode = 5;
 PixelXDimension = 2816;
 PixelYDimension = 2112;
 SceneCaptureType = 0;
 SensingMethod = 2;
 ShutterSpeedValue = &amp;quot;4.65625&amp;quot;;
 WhiteBalance = 0;
 }
 2013-02-25 17:31:22.261 ImageIODemo[2571:303] key = PixelWidth value = 2816
 2013-02-25 17:31:22.262 ImageIODemo[2571:303] key = PixelHeight value = 2112
 2013-02-25 17:31:22.262 ImageIODemo[2571:303] key = {IPTC} value = {
 &amp;quot;Caption/Abstract&amp;quot; = &amp;quot;                               &amp;quot;;
 StarRating = 0;
 }
 2013-02-25 17:31:22.262 ImageIODemo[2571:303] key = {MakerCanon} value = {
 ContinuousDrive = 0;
 ImageSerialNumber = 1785006;
 MaxAperture = &amp;quot;2.708511093873785&amp;quot;;
 MinAperture = 8;
 UniqueModelID = 50593792;
 WhiteBalanceIndex = 0;
 }
 2013-02-25 17:31:22.263 ImageIODemo[2571:303] key = ProfileName value = sRGB IEC61966-2.1
 2013-02-25 17:31:22.263 ImageIODemo[2571:303] key = {ExifAux} value = {
 AFInfo =     (
 &amp;quot;0.23&amp;quot;,
 &amp;quot;0.23&amp;quot;,
 &amp;quot;0.18&amp;quot;,
 &amp;quot;0.18&amp;quot;,
 n,
 &amp;quot;0.41&amp;quot;,
 &amp;quot;0.23&amp;quot;,
 &amp;quot;0.18&amp;quot;,
 &amp;quot;0.18&amp;quot;,
 n,
 &amp;quot;0.59&amp;quot;,
 &amp;quot;0.23&amp;quot;,
 &amp;quot;0.18&amp;quot;,
 &amp;quot;0.18&amp;quot;,
 n,
 &amp;quot;0.23&amp;quot;,
 &amp;quot;0.41&amp;quot;,
 &amp;quot;0.18&amp;quot;,
 &amp;quot;0.18&amp;quot;,
 n,
 &amp;quot;0.41&amp;quot;,
 &amp;quot;0.41&amp;quot;,
 &amp;quot;0.18&amp;quot;,
 &amp;quot;0.18&amp;quot;,
 n,
 &amp;quot;0.59&amp;quot;,
 &amp;quot;0.41&amp;quot;,
 &amp;quot;0.18&amp;quot;,
 &amp;quot;0.18&amp;quot;,
 f,
 &amp;quot;0.23&amp;quot;,
 &amp;quot;0.59&amp;quot;,
 &amp;quot;0.18&amp;quot;,
 &amp;quot;0.18&amp;quot;,
 n,
 &amp;quot;0.41&amp;quot;,
 &amp;quot;0.59&amp;quot;,
 &amp;quot;0.18&amp;quot;,
 &amp;quot;0.18&amp;quot;,
 f,
 &amp;quot;0.59&amp;quot;,
 &amp;quot;0.59&amp;quot;,
 &amp;quot;0.18&amp;quot;,
 &amp;quot;0.18&amp;quot;,
 n
 );
 Firmware = &amp;quot;Firmware Version 1.00&amp;quot;;
 FlashCompensation = 0;
 FocusMode = 1;
 ImageStabilization = 3;
 LensInfo =     (
 &amp;quot;4.3&amp;quot;,
 &amp;quot;21.5&amp;quot;,
 0,
 0
 );
 LensModel = &amp;quot;4.3-21.5 mm&amp;quot;;
 }
 2013-02-25 17:31:22.264 ImageIODemo[2571:303] key = DPIWidth value = 180
 2013-02-25 17:31:22.264 ImageIODemo[2571:303] key = DPIHeight value = 180
 2013-02-25 17:31:22.265 ImageIODemo[2571:303] key = ColorModel value = RGB
 2013-02-25 17:31:22.265 ImageIODemo[2571:303] key = Orientation value = 1
 2013-02-25 17:31:22.265 ImageIODemo[2571:303] key = Depth value = 8
 */
&lt;/pre&gt;
</summary></entry><entry><title>opengles2.0那些事之一</title><link href="http://xiangyuan.github.io/posts/2013/02/04/opengles20na-xie-shi-zhi/" rel="alternate"></link><updated>2013-02-04T11:41:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2013-02-04:posts/2013/02/04/opengles20na-xie-shi-zhi/</id><summary type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;自从计划学习opengles以来，一直也没有做过记录。今天也算是第一篇吧，本人也是菜鸟，也看各种文章去学习。&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;至于那些介绍就不说，网上介绍还是比较的多的。我只记录要点。&lt;/div&gt;
&lt;div class="line"&gt;在OpenGL&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2013/opengles2.0_one.rst&lt;/tt&gt;, line 9)&lt;/p&gt;
Line block ends without a blank line.&lt;/div&gt;
&lt;p&gt;ES规范要求每个实现都提供了一种机制，应用程序可以使用它来创建一个帧缓冲来保存渲染的图像。在iOS上，使用帧缓冲对象，这是建立在OpenGL
ES 2.0的所有帧缓存，并提供所有iOS实现的OpenGL ES
1.1的GL_OES_framebuffer_object扩展。
|  帧缓冲对象允许您的应用程序能够精确地控制 color,depth,sentcil
targets您还可以创建多个帧缓冲对象在一个单一context中，可能在帧缓冲区之间的资源共享。
|  一般步骤：
|  1、create the frame buffer
|  2、create a frame buffer object
|
3、创建一个或多个的目标（renderbuffers或纹理），分配存储空间，并且将每个帧缓冲对象的连接点上。
|  测试的framebuffer的完整性。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;在ios上流程如下图。&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;img alt="image0" src="https://photos-5.dropbox.com/t/0/AAAKRhPEqFRXpTB2zn8SYebvLMVaqsxjJTnkMn0mJg3cFg/12/125005714/jpeg/32x32/3/_/1/2/Photo%2012-12-27%2017%2008%2030.jpg/P5IfzzmBT2mRFE2kP_ZyKt9F4984yzsx5MIRXS0FZVQ?size=1024x768" /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;glcontext----》pipline处理---》render-----》vision&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;在es2.0中很重要的一个部分是顶点，下图是一个关于es20也是opengl的处理过程。&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;a class="reference external" href="http://kingiol.com/bl/wp-content/uploads/2013/05/11.jpg"&gt;&lt;img alt="image1" src="http://kingiol.com/bl/wp-content/uploads/2013/05/11-300x210.jpg" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;上图顶点shader可以完成&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;1、顶点转换&lt;/div&gt;
&lt;div class="line"&gt;2、光照计算（per-vertex 色彩）&lt;/div&gt;
&lt;div class="line"&gt;3、变换纹理坐标。&lt;/div&gt;
&lt;div class="line"&gt;顶点shader属性如下图&lt;/div&gt;
&lt;div class="line"&gt;&lt;a class="reference external" href="http://kingiol.com/bl/wp-content/uploads/2013/05/111.jpg"&gt;&lt;img alt="image2" src="http://kingiol.com/bl/wp-content/uploads/2013/05/111-300x222.jpg" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;顶点的坐标需要转换，如下图&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;a class="reference external" href="http://kingiol.com/bl/wp-content/uploads/2013/05/112.jpg"&gt;&lt;img alt="image3" src="http://kingiol.com/bl/wp-content/uploads/2013/05/112-300x118.jpg" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;2。裁减空间&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;a class="reference external" href="http://kingiol.com/bl/wp-content/uploads/2013/05/113.jpg"&gt;&lt;img alt="image4" src="http://kingiol.com/bl/wp-content/uploads/2013/05/113-300x168.jpg" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;3、视口变换&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;4、光栅化(Rasterization)&lt;/div&gt;
&lt;div class="line"&gt;&lt;a class="reference external" href="http://kingiol.com/bl/wp-content/uploads/2013/05/114.jpg"&gt;&lt;img alt="image5" src="http://kingiol.com/bl/wp-content/uploads/2013/05/114-300x145.jpg" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;vertex shader ---&amp;gt;fragment shader 输出过程中的处理。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;5、在三角形图元在光栅化之前，需要决定哪个是front-face 和back-face&lt;/div&gt;
&lt;/div&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2013/opengles2.0_one.rst&lt;/tt&gt;, line 51)&lt;/p&gt;
Line block ends without a blank line.&lt;/div&gt;
&lt;p&gt;,front-face面对观察者的
|  &lt;a class="reference external" href="http://kingiol.com/bl/wp-content/uploads/2013/05/115.jpg"&gt;&lt;img alt="image6" src="http://kingiol.com/bl/wp-content/uploads/2013/05/115-300x131.jpg" /&gt;&lt;/a&gt;
|  使用glFrontFace(GLenum dir) 来决定是顺时针方向还是逆时针方向
|  dir: GL_CW or GL_CCW default value is CL_CCW
|  6、cull (去除光栅化操作面)
|  glCullFace(GLenum mode)
|  mode :选择GL_FRONT GL_BACK GL_FRONT_BACK 默认是gl_back
|  cull操作需要开启 GL_CULL_FACE 开启glenable
|  注意：防止GPU费时去光栅化不可见区域，开启cull操作&lt;/p&gt;
&lt;p&gt;上面是opengl的大体处理流程，其间还有一个东西就是buffer object
data。还有一些光照，纹理等操作。后面再发文章。随后会发一个实例流程，来说明ios中的开发过程。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;参考文章：&lt;/div&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2013/opengles2.0_one.rst&lt;/tt&gt;, line 65)&lt;/p&gt;
Line block ends without a blank line.&lt;/div&gt;
&lt;p&gt;1。官方http://developer.apple.com/library/ios/#documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html
|  2、大神 &lt;a class="reference external" href="http://db-in.com/blog/"&gt;http://db-in.com/blog/&lt;/a&gt;
|  3、jeff blog :
&lt;a class="reference external" href="http://iphonedevelopment.blogspot.com/2010/11/opengl-es-20-for-ios-chapter-4.html"&gt;http://iphonedevelopment.blogspot.com/2010/11/opengl-es-20-for-ios-chapter-4.html&lt;/a&gt;&lt;/p&gt;
</summary></entry><entry><title>拍照界面的定制</title><link href="http://xiangyuan.github.io/posts/2013/01/30/pai-zhao-jie-mian-de-ding-zhi/" rel="alternate"></link><updated>2013-01-30T16:18:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2013-01-30:posts/2013/01/30/pai-zhao-jie-mian-de-ding-zhi/</id><summary type="html">&lt;p&gt;下面是通AVFoundation进行图像摄取，然后定制所显示的界面&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;AVCaptureSession使用，参照官方文档。&lt;/div&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="https://developer.apple.com/library/ios/#documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/04_MediaCapture"&gt;https://developer.apple.com/library/ios/#documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/04_MediaCapture&lt;/a&gt;.html#//apple_ref/doc/uid/TP40010188-CH5-SW2&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;原理图&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;img alt="image0" src="https://developer.apple.com/library/ios/documentation/AudioVideo/Conceptual/AVFoundationPG/Art/captureDetail.png" /&gt;&lt;/div&gt;
&lt;div class="line"&gt;下面是效果图如下，比较的简陋。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="http://kingiol.com/bl/wp-content/uploads/2013/01/Screenshot-2013.01.30-15.58.03.png"&gt;&lt;img alt="image1" src="http://kingiol.com/bl/wp-content/uploads/2013/01/Screenshot-2013.01.30-15.58.03-200x300.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用步骤；&lt;/p&gt;
&lt;p&gt;1、创建AVCaptureSesssion&lt;/p&gt;
&lt;p&gt;2、添加输入设备AVCaptureDeviceInput&lt;/p&gt;
&lt;p&gt;3、设置预览层&lt;/p&gt;
&lt;pre class="literal-block"&gt;
    _captureSession = [[AVCaptureSession alloc]init];
    // Do any additional setup after loading the view, typically from a nib.
    AVCaptureDevice * device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];
    if (device) {
        NSError * error;
        AVCaptureDeviceInput * deviceInput = [AVCaptureDeviceInput deviceInputWithDevice:device error:&amp;amp;error];
        if (!error) {
            if ([_captureSession canAddInput:deviceInput]) {
                [_captureSession addInput:deviceInput];
            } else {
                NSLog(&amp;#64;&amp;quot;No input&amp;quot;);
            }
        } else {
            NSLog(&amp;#64;&amp;quot;device input encounter some error %&amp;#64;&amp;quot;,[error description]);
        }
    }
    else
        NSLog(&amp;#64;&amp;quot;no device input&amp;quot;);

    //2.add the device preview
    _previewLayer = [[AVCaptureVideoPreviewLayer alloc]initWithSession:_captureSession];
    [_previewLayer setVideoGravity:AVLayerVideoGravityResizeAspectFill];

    //3. add the preview layer
    CGRect frame = self.view.frame;
    _previewLayer.frame = frame;
//    _previewLayer.position =
    [[self.view layer] addSublayer:_previewLayer];
    [_previewLayer release];

    UIButton * button = [UIButton buttonWithType:UIButtonTypeRoundedRect];
    button.frame = CGRectMake(80.f, 120.f, 100.f, 44.f);
    [button addTarget:self action:&amp;#64;selector(buttonClicked:) forControlEvents:UIControlEventTouchUpInside];
    [button setTitle:&amp;#64;&amp;quot;Capture&amp;quot; forState:UIControlStateNormal];

    [self.view addSubview:button];

    [_captureSession startRunning];
&lt;/pre&gt;
</summary></entry><entry><title>apple个人开发者证书无线发布app的实现</title><link href="http://xiangyuan.github.io/posts/2013/01/21/applege-ren-kai-fa-zhe-zheng-shu-wu-xian-fa-bu-appde-shi-xian/" rel="alternate"></link><updated>2013-01-21T14:23:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2013-01-21:posts/2013/01/21/applege-ren-kai-fa-zhe-zheng-shu-wu-xian-fa-bu-appde-shi-xian/</id><summary type="html">&lt;p&gt;apple个人开发者证书无线发布app的实现，也就是说不经过发布到app
store，直接在ios设备上安装app，注：ios设备不需要越狱。&lt;/p&gt;
&lt;p&gt;之所以有这篇文章的产生，可以看这里：&lt;/p&gt;
&lt;p&gt;不通过App Store，在iOS设备上直接安装应用程序&lt;/p&gt;
&lt;p&gt;以上步骤顺利经过测试。在摸索过程中参考了以下几篇文章，粘贴一下，以表示对作者迷途指导的感激之情。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://aaronparecki.com/articles/2011/01/21/1/how-to-distribute-your-ios-apps-over-the-air"&gt;具体参考下面文章&lt;/a&gt;&lt;/p&gt;
</summary></entry><entry><title>lbs之两坐标点之间的距离</title><link href="http://xiangyuan.github.io/posts/2012/12/27/lbszhi-liang-zuo-biao-dian-zhi-jian-de-ju-chi/" rel="alternate"></link><updated>2012-12-27T21:51:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-27:posts/2012/12/27/lbszhi-liang-zuo-biao-dian-zhi-jian-de-ju-chi/</id><summary type="html">&lt;p&gt;在LBS应用中，需要知到两坐标点之间的距离，从而在手机应用中实现离自己多少距离的附近的人员。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;计算方法从Haversine formula 这个公式得来。&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;查看wiki : &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Haversine_formula"&gt;Haversine公式&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;下面写出的php实现，&lt;/p&gt;
&lt;pre class="literal-block"&gt;
public class LBS {
    private $earthRadius = 6367000;

    /*
     * Using the Haversine formula
     *
     *http://en.wikipedia.org/wiki/Haversine_formula
     * calculate the distance
     */
    public function getDistance($lant1,$lon1,$lant2,$lon2) {
        $nDlat = ($lant1 - $lant2) * pi() / 180;
        $nDlon = ($lon1 - $lon2) * pi() / 180;

        $nA = pow (sin($nDlat / 2),2) + cos($nDlat) * cos($nDlat) * pow(sin($nDlon / 2),2);

        $nC = 2 * atan(sqrt($nA),sqrt(1 - $nA));
        $nD = $earthRadius * $nC;
        return $nD;
    }
}
&lt;/pre&gt;
&lt;p&gt;就可以计算地球上面两个位置点之间的距离。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;现在引起另外一问题，如果数据量大时，查找附近人的方法。网上有专门介绍方法的。参见。|  &lt;a class="reference external" href="http://tech.idv2.com/2011/07/05/geohash-intro/"&gt;查找附近人的方法&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
</summary></entry><entry><title>使用他人app里面图片</title><link href="http://xiangyuan.github.io/posts/2012/12/26/shi-yong-ta-ren-appli-mian-tu-pian/" rel="alternate"></link><updated>2012-12-26T14:20:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-26:posts/2012/12/26/shi-yong-ta-ren-appli-mian-tu-pian/</id><summary type="html">&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/extract_other_app_images.rst&lt;/tt&gt;, line 2)&lt;/p&gt;
&lt;p&gt;Title underline too short.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
使用他人app里面图片
##################
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;有时候我们看到某个app中有个有趣的图片，想获得这个图片，可以从该app的程序包中提取&lt;/p&gt;
&lt;p&gt;1、首先在itunes里面打开ipa包。&lt;/p&gt;
&lt;p&gt;2、使用归档工具解压查看。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;3、有些png图片无法用”预览”程序显示,原因是Xcode在打包程序时，使用一个名为pngcrush的工具对png图片针对iphone进行了压缩优化处理，导致这些图片无法正常显示（可正常显示的png图片经pngcrush处理后无变化），pngcrush程序在Xcode的安装目录中存在，路径为/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/pngcrush&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;使用方法为&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;$ /Applications/Xcode.app/Contents/Developer\&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;/Platforms/iPhoneOS.platform/Developer/usr/bin/pngcrush \&lt;/div&gt;
&lt;div class="line"&gt;-revert-iphone-optimizations -q xx.png xx_revert.png&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;就可以将图片还原。&lt;/p&gt;
</summary></entry><entry><title>图层几何(文档)</title><link href="http://xiangyuan.github.io/posts/2012/12/19/tu-ceng-ji-he-wen-dang/" rel="alternate"></link><updated>2012-12-19T09:06:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-19:posts/2012/12/19/tu-ceng-ji-he-wen-dang/</id><summary type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;动画主题里面&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;虽然图层和图层树与视图和视图的结构在很多方面具有相似性,但是图层的几何&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/gemotry.rst&lt;/tt&gt;, line 8)&lt;/p&gt;
Line block ends without a blank line.&lt;/div&gt;
&lt;p&gt;却不同,它更加简单通俗。图层的所有几何属性,包括图层的矩阵变换,都可以隐式
和显式动画。
|  下图显示可以在上下文中指定图层几何的属性:
|  &lt;a class="reference external" href="http://kingiol.com/bl/wp-content/uploads/2012/12/Screen-Shot-2012-12-19-at-9.04.31-AM.png"&gt;&lt;img alt="image0" src="http://kingiol.com/bl/wp-content/uploads/2012/12/Screen-Shot-2012-12-19-at-9.04.31-AM-300x172.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;图层的 position 属性是一个 CGPoint&lt;/div&gt;
&lt;/div&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/gemotry.rst&lt;/tt&gt;, line 15)&lt;/p&gt;
Line block ends without a blank line.&lt;/div&gt;
&lt;p&gt;的值,它指定图层相当于它父图层的位置, 该值基于父图层的坐标系。
|  图层的 bounds 属性是一个 CGRect
的值,指定图层的大小(bounds.size)和图层的
原点(bounds.origin)。当你重写图层的重画方法的时候,bounds
的原点可以作为图形 上下文的原点。&lt;/p&gt;
&lt;p&gt;图层拥有一个隐式的 frame,它是 position,bounds,anchorPoint 和 transform
属性 的一部分。设置新的 frame 将会相应的改变图层的 position 和 bounds
属性,但是 frame 本身并没有被保存。但是设置新的 frame 时候,bounds
的原点不受干扰,bounds 的大 小变为 frame 的大小,即
bounds.size=frame.size。图层的位置被设置为相对于锚点 (anchor
point)的适合位置。当你设置 frame 的值的时候,它的计算方式和 position、
bounds、和 anchorPoint 的属性相关。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;图层的 anchorPoint 属性是一个 CGPoint 值,它指定了一个基于图层 bounds&lt;/div&gt;
&lt;/div&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/gemotry.rst&lt;/tt&gt;, line 30)&lt;/p&gt;
Line block ends without a blank line.&lt;/div&gt;
&lt;p&gt;的符 合位置坐标系的位置。锚点(anchor point)指定了 bounds 相对于 position
的值,同
时也作为变换时候的支点。锚点使用单元空间坐标系表示,(0.0,0.0)点接近图层
的原点,而(1.0,1.0)是原点的对角点。改变图层的父图层的变换属性(如果存在
的话)将会影响到 anchorPoint 的方向,具体变化取决于父图层坐标系的 Y 轴。
|  当你设置图层的 frame 属性的时候,position
会根据锚点(anchorPoint)相应的改 变,而当你设置图层的 position
属性的时候,bounds 会根据锚点(anchorPoint)做相应 的改变。
|  iOS 注意:以下示例描述基于 Mac OS X
的图层,它的坐标系原点基于左下角。在 iOS 上面,
图层的坐标系原点位于左上角,原点向下和向右为正值。这变化用具体数值显示,而不是概念描￼述。&lt;/p&gt;
</summary></entry><entry><title>ios一个汽泡聊天页面</title><link href="http://xiangyuan.github.io/posts/2012/12/18/ios-ge-qi-pao-liao-tian-ye-mian/" rel="alternate"></link><updated>2012-12-18T17:17:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-18:posts/2012/12/18/ios-ge-qi-pao-liao-tian-ye-mian/</id><summary type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;效果如图所示。&lt;/div&gt;
&lt;/div&gt;
&lt;img alt="chat Screenshot" class="image" src="images/Screenshot.png" style="width: 200px; height: 300px;" /&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/xiangyuan/BubbleMsg"&gt;项目地址：https://github.com/xiangyuan/BubbleMsg&lt;/a&gt;&lt;/p&gt;
</summary></entry><entry><title>cocos2d中与ios中加载custom fonts</title><link href="http://xiangyuan.github.io/posts/2012/12/05/cocos2dzhong-yu-ioszhong-jia-zai-custom-fonts/" rel="alternate"></link><updated>2012-12-05T11:51:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-05:posts/2012/12/05/cocos2dzhong-yu-ioszhong-jia-zai-custom-fonts/</id><summary type="html">&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/coacos2d_ios_custom_fonts.rst&lt;/tt&gt;, line 5)&lt;/p&gt;
Field list ends without a blank line; unexpected unindent.&lt;/div&gt;
&lt;p&gt;:category:ios&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;a class="reference external" href="http://www.webpagepublicity.com/free-fonts.html#FreeFonts"&gt;下载免费字体&lt;/a&gt;&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;加载客户字体的一般步骤为&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;将ttf字体文件加入到工程资源文件中，确保在bundle里面可以找到。&lt;/li&gt;
&lt;li&gt;向工程的Info.Plist文件中添加UIAppFonts的键值。&lt;/li&gt;
&lt;li&gt;向2中的键值里面添加array对象的fonts名字。&lt;/li&gt;
&lt;li&gt;保存Info.Plist文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;&lt;p&gt;可以通过如下方式进行文字使用。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;pre class="literal-block"&gt;
[_mLabel setFont:[UIFont fontWithName:&amp;#64;&amp;quot;Alpha Romanie Outline G98&amp;quot; size:20]];
[_mLabel setText:&amp;#64;&amp;quot;What Happened&amp;quot;];
&lt;/pre&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;特别注意。&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;在上面操作过程中，[UIFont fontWithName:&amp;#64;&amp;quot;Alpha Romanie Outline G98&amp;quot;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/coacos2d_ios_custom_fonts.rst&lt;/tt&gt;, line 41)&lt;/p&gt;
Line block ends without a blank line.&lt;/div&gt;
&lt;p&gt;size:20]]加载使用的名字并不是文件的名字。
|  真实名可以通过双击ttf文件可以看到。否则就会加载不成功。&lt;/p&gt;
</summary></entry><entry><title>ios所有支持的字型名称以及相关样式</title><link href="http://xiangyuan.github.io/posts/2012/12/03/iossuo-you-zhi-chi-de-zi-xing-ming-cheng-yi-ji-xiang-guan-yang-shi/" rel="alternate"></link><updated>2012-12-03T12:00:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-03:posts/2012/12/03/iossuo-you-zhi-chi-de-zi-xing-ming-cheng-yi-ji-xiang-guan-yang-shi/</id><summary type="html">&lt;p&gt;发现一个很不错的东东&lt;/p&gt;
&lt;p&gt;对比所有的ios字体样式。&lt;/p&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://kingiol.com/bl/wp-content/uploads/2012/12/t.jpg"&gt;&lt;img alt="image0" src="http://kingiol.com/bl/wp-content/uploads/2012/12/t-300x167.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;连接地址&amp;nbsp;&lt;a class="reference external" href="http://iosfonts.com/"&gt;http://iosfonts.com/&lt;/a&gt;&lt;/p&gt;
</summary></entry><entry><title>cocos2d之入门</title><link href="http://xiangyuan.github.io/posts/2012/12/03/cocos2dzhi-ru-men/" rel="alternate"></link><updated>2012-12-03T11:16:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-03:posts/2012/12/03/cocos2dzhi-ru-men/</id><summary type="html">&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/cocos2d_tutorail.rst&lt;/tt&gt;, line 4)&lt;/p&gt;
Field list ends without a blank line; unexpected unindent.&lt;/div&gt;
&lt;p&gt;:category:cocos2d&lt;/p&gt;
&lt;p&gt;cocos2d中核心以前关键的一些类别&lt;/p&gt;
&lt;p&gt;像是现实如下的电影流程&lt;/p&gt;
&lt;p&gt;导演---》场景--》各种层--》然后加杂着一些动作&lt;/p&gt;
&lt;p&gt;CCDirector&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;切换场景&lt;/li&gt;
&lt;li&gt;存储cocos2d配置信息&lt;/li&gt;
&lt;li&gt;访问视图（uiview opengl等）&lt;/li&gt;
&lt;li&gt;暂停、恢复和终止游戏&lt;/li&gt;
&lt;li&gt;uikit与opengl坐标之间的转换。&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;&lt;p&gt;这个类在整个框架里面像是一个mediator模式。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;第二个概念&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;&lt;p&gt;CCSecene&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;&lt;ol class="arabic simple"&gt;
&lt;li&gt;包括很多layer元素 综合就构成了一个场景&lt;/li&gt;
&lt;li&gt;然后会有ccsprite精灵。&lt;/li&gt;
&lt;li&gt;还有一些文字。&lt;/li&gt;
&lt;li&gt;菜单等&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;&lt;p&gt;CCSprite:&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;CCLabel&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;CCAction&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;CCLayer等&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;&lt;p&gt;下面是类层次结构图&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;&lt;p&gt;&lt;a class="reference external" href="http://kingiol.com/bl/wp-content/uploads/2012/12/inherit_graph_1.png"&gt;&lt;img alt="image0" src="http://kingiol.com/bl/wp-content/uploads/2012/12/inherit_graph_1-283x300.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;&lt;p&gt;action图2&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;&lt;p&gt;&lt;a class="reference external" href="http://kingiol.com/bl/wp-content/uploads/2012/12/inherit_graph_2.png"&gt;&lt;img alt="image1" src="http://kingiol.com/bl/wp-content/uploads/2012/12/inherit_graph_2-206x300.png" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</summary></entry><entry><title>ios Image裁剪成圆形的方法</title><link href="http://xiangyuan.github.io/posts/2012/12/03/ios-imagecai-jian-cheng-yuan-xing-de-fang-fa/" rel="alternate"></link><updated>2012-12-03T10:43:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-03:posts/2012/12/03/ios-imagecai-jian-cheng-yuan-xing-de-fang-fa/</id><summary type="html">&lt;p&gt;各种应用上面有很多圆形的图片显示。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;如下图&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;a class="reference external" href="http://kingiol.com/bl/wp-content/uploads/2012/12/Screenshot-2012.12.02-12.39.26.png"&gt;&lt;img alt="image0" src="http://kingiol.com/bl/wp-content/uploads/2012/12/Screenshot-2012.12.02-12.39.26-200x300.png" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;我知道的实现方法有三种。&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;1、通过image mask来操作，需要添加mask目标图片。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;2、通过imageview的layer来操作&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;如下代码&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;pre class="literal-block"&gt;
UIImageView * imageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:&amp;#64;&amp;quot;oiuyfdsa.png&amp;quot;]];
imageView.frame = CGRectMake(20.f, 20.f, 100.f, 100.f);
imageView.layer.masksToBounds = YES;
imageView.layer.cornerRadius = 50;
&lt;/pre&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;a.这种方法需要添加QuarztCore框架才能操作&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;b.cornerradus的确定问题&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;3、能过代码对画布裁剪成圆形--》然后再将原始图像画出来--》&lt;/p&gt;
&lt;pre class="literal-block"&gt;
-(UIImage*) circleImage:(UIImage*) image withParam:(CGFloat) inset {
    UIGraphicsBeginImageContext(image.size);
    CGContextRef context = UIGraphicsGetCurrentContext();
    CGContextSetLineWidth(context, 2);
    CGContextSetStrokeColorWithColor(context, [UIColor redColor].CGColor);
    CGRect rect = CGRectMake(inset, inset, image.size.width - inset * 2.0f, image.size.height - inset * 2.0f);
    CGContextAddEllipseInRect(context, rect);
    CGContextClip(context);

    [image drawInRect:rect];
    CGContextAddEllipseInRect(context, rect);
    CGContextStrokePath(context);
    UIImage *newimg = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return newimg;
}
&lt;/pre&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;上面代码注意 如果裁剪后没有使用 CGContextAddEllipseInRect(context,&lt;/div&gt;
&lt;/div&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/ios_image_round.rst&lt;/tt&gt;, line 50)&lt;/p&gt;
Line block ends without a blank line.&lt;/div&gt;
&lt;p&gt;rect);
|  CGContextStrokePath(context); 这条代码
就会引起背景为白色时看不出来任务效果。
|  这里是椭圆操作
|  圆操作你懂的。&lt;/p&gt;
</summary></entry><entry><title>ios开发或android开发工具之抓包</title><link href="http://xiangyuan.github.io/posts/2012/12/03/ioskai-fa-huo-androidkai-fa-gong-ju-zhi-zhua-bao/" rel="alternate"></link><updated>2012-12-03T10:32:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-03:posts/2012/12/03/ioskai-fa-huo-androidkai-fa-gong-ju-zhi-zhua-bao/</id><summary type="html">&lt;p&gt;在开发过程中 或是查看别人应用向服务端发送了什么数据&lt;/p&gt;
&lt;p&gt;或是调用的接口，比如说papa图片录音的实现问题，它其实是分开的两部分内容，并不是将声音加在图片数据之上。而且音频格式是mp3
的。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;工具连接地址&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;a class="reference external" href="http://www.charlesproxy.com/"&gt;charles&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary></entry><entry><title>uiscrollview覆盖子视图时引起的背景视图无事件</title><link href="http://xiangyuan.github.io/posts/2012/12/03/uiscrollviewfu-gai-zi-shi-tu-shi-yin-qi-de-bei-jing-shi-tu-wu-shi-jian/" rel="alternate"></link><updated>2012-12-03T10:26:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-03:posts/2012/12/03/uiscrollviewfu-gai-zi-shi-tu-shi-yin-qi-de-bei-jing-shi-tu-wu-shi-jian/</id><summary type="html">&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/uiscrollview_cover_bottom.rst&lt;/tt&gt;, line 4)&lt;/p&gt;
Field list ends without a blank line; unexpected unindent.&lt;/div&gt;
&lt;p&gt;:category:ios&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;上一篇我们说到的问题。如标题所示，开始问了一哥们。告诉我是不能解决。&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;根据我各种看文档发现这个问题也是可以解决的。那就是需要我们的视图重写&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;pre class="literal-block"&gt;
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
&lt;/pre&gt;
&lt;p&gt;这个方法 然后根据是否在背景子视图的区域来&lt;/p&gt;
&lt;p&gt;hitTest:withEvent:方法的处理流程如下:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内；&lt;/li&gt;
&lt;li&gt;若返回NO,则hitTest:withEvent:返回nil;&lt;/li&gt;
&lt;li&gt;若返回YES,则向当前视图的所有子视图(subviews)发送hitTest:withEvent:消息，所有子视图的遍历顺序是从top到bottom，即从subviews数组的末尾向前遍历,直到有子视图返回非空对象或者全部子视图遍历完毕；&lt;/li&gt;
&lt;li&gt;若第一次有子视图返回非空对象,则hitTest:withEvent:方法返回此对象，处理结束；&lt;/li&gt;
&lt;li&gt;如所有子视图都返回非，则hitTest:withEvent:方法返回自身(self)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;就可以解决问题了&lt;/p&gt;
</summary></entry><entry><title>小总结--2012-4-24</title><link href="http://xiangyuan.github.io/posts/2012/12/03/xiao-zong-jie-2012-4-24/" rel="alternate"></link><updated>2012-12-03T10:09:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-03:posts/2012/12/03/xiao-zong-jie-2012-4-24/</id><summary type="html">&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/summary.rst&lt;/tt&gt;, line 6)&lt;/p&gt;
Field list ends without a blank line; unexpected unindent.&lt;/div&gt;
&lt;p&gt;:category:碎碎念&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;回首过去的一年，从一个青涩的实习生慢慢走来。如今变成了一个某中意义上的老员工、&lt;/div&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/summary.rst&lt;/tt&gt;, line 9)&lt;/p&gt;
Line block ends without a blank line.&lt;/div&gt;
&lt;p&gt;前辈。想想这一年自己学习到了些什么，个人又成长了什么。因为是一个码农，所以吐槽一下。
|  一、 技术上：
|
从第一次接触github、bitbucket，到成为开源社区中的一只小小虫。仍记得大学里
|
面学习linux时的飘忽，根本就没有怎么地用过，再到后来的没有咋地用windows了。亲，这个世界变化真快。还记得那些年学的c++被自己丢的十万八千里了。再到混开源社区，拾起了c开发，也许这些以前不会想到。这就如恋爱，曾经以后自己很爱，不会忘记的沈家宜。也许在未来的某天，重新发现那些很需要的东西就那样的变淡了，可能就剩偶尔内心的一丝感伤与心灵些许难以释怀吧。
|
从看github里的第一个项目，当时好像是一个叫freerdp的项目，人生第一次发现，原来c代码可以写的那么优雅，那么酷，会让人迷恋的感觉。完完全全把我在大学里见的东西给颠覆了，发现大学里面的那些被忘的差不多的东西是那么垃圾。还记得张三丰教张无忌学太极剑时吧，最后一遍时问你还记得多少，得到的答案是全部忘记了。还好没有记得多少大学里面的东西了，也说明了人生的另一种学习观，保持一种清空的状态。一种从零开始的状态，不断的进步吧。从没有学过c到熟练使用c，这可许是工作后进步最大的一件事件吧。
|
记得大学时想去实现的事件，一定要学ios开发，这件事情也是工作后的另一大进步吧。
|
如今也虽然会了object-c的东西，却没有去实际的项目驱动吧。这个部分还会继续study下去。
|
还有就是看各种行业的一些动态，然后越发的自己懵懂了。还学习了一些其他比较杂的东西。然后就是参与一些开源项目。
|  二、 生活上
|
这个方面吧，不太好说，算是比较混乱吧。可能您会觉得我比较无趣，大部分时间跟code过了。可能并不是每个人都会理解偶尔星巴克里code的那种状态。有几个志同道合的码农一块聊天，偶尔一起吃个饭，也还过的不孤单。情感上并不太行哈，身边净是一群基友，哈哈。不过以后“您”在那里。
|  三、 未来规划
|  曾经见到过这样一句话，“想想要成为什么样的人?
如何成为这样的人?”。虽然自己一直也没有想清楚。所以可能又会继续做技术宅男，一些人心中的2B青年吧。前辈也跟我说自己想什么方向发展，对工作的环境又怎样的看待，自己的期待又是什么样子。这些问题我都会去想想。&lt;/p&gt;
&lt;p&gt;好了 原谅一个2B青年的吐槽吧。&lt;/p&gt;
</summary></entry><entry><title>ios中使用google voice</title><link href="http://xiangyuan.github.io/posts/2012/12/03/ioszhong-shi-yong-google-voice/" rel="alternate"></link><updated>2012-12-03T10:07:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-03:posts/2012/12/03/ioszhong-shi-yong-google-voice/</id><summary type="html">&lt;p&gt;现在主流的应用添加语音转中文的服务多数使用的科大讯飞的语音识别。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;缺点：&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;1、精确度不够。&lt;/div&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/ios_google_voice.rst&lt;/tt&gt;, line 11)&lt;/p&gt;
Line block ends without a blank line.&lt;/div&gt;
&lt;p&gt;2、新的表态库里面加了umeng统计，导致与你自己项目里面的一些东西会参生冲突。
|  3、使用的是sbjson框架解析json数据，速度慢。
|  4、你的工程编译linker参数里面不能加 -all_load
不然就会引起相当大的问题。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;以下使用的google voice的api是网上chrome的语音识别的api。&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;优点是很精确 ，纠结点是 被GFW屏蔽 然后很是不稳定。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;你可以将你的数据发到你自己的服务端 然后再转到google上去。&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;地址在我的bitbucket上面&lt;/div&gt;
&lt;div class="line"&gt;&lt;a class="reference external" href="https://bitbucket.org/xiangyuan/iphonegooglevoice"&gt;地址在我的bitbucket上面&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary></entry><entry><title>ios下实现类似微信录音时的ui</title><link href="http://xiangyuan.github.io/posts/2012/12/03/iosxia-shi-xian-lei-si-wei-xin-lu-yin-shi-de-ui/" rel="alternate"></link><updated>2012-12-03T09:51:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-03:posts/2012/12/03/iosxia-shi-xian-lei-si-wei-xin-lu-yin-shi-de-ui/</id><summary type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;不说废话直接上图&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;img alt="image0" src="https://raw.github.com/xiangyuan/soundrecorderui/master/screeShot.png" /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;下面进度的显示是使用的一个进度条 然后进行重新定制而产生的。&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;还可以通过图片来完成。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;下面是github地址&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;a class="reference external" href="https://github.com/xiangyuan/soundrecorderui"&gt;github地址&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary></entry><entry><title>ios中打印视图的子视图</title><link href="http://xiangyuan.github.io/posts/2012/12/03/ioszhong-da-yin-shi-tu-de-zi-shi-tu/" rel="alternate"></link><updated>2012-12-03T09:39:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-03:posts/2012/12/03/ioszhong-da-yin-shi-tu-de-zi-shi-tu/</id><summary type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;ios中有时想看uikit里面类里所带的所有子视图&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;以便我们重新定制&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;因为定制方式有：&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;1、重合，多个组件的重新组合来达到目标。&lt;/div&gt;
&lt;div class="line"&gt;2、继承uikit里面的组件进新重新添加。&lt;/div&gt;
&lt;div class="line"&gt;3、继承uikit组件然后再重画&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;所以就有看的需求。&lt;/p&gt;
&lt;pre class="literal-block"&gt;
NSString* getFullClassDescription(Class klass) {
    NSString *description = [klass description];
    while ([klass superclass])
    {
        klass = [klass superclass];
        description = [description stringByAppendingFormat:&amp;#64;&amp;quot;:%&amp;#64;&amp;quot;, [klass description]];
    }
    return description;
}


void dumpViews(UIView* view, NSString *label, NSString *indent)  {
    Class klass = [view class];
    NSString *classDescription = getFullClassDescription(klass);
    if ([label compare:&amp;#64;&amp;quot;&amp;quot;] == NSOrderedSame)
        NSLog(&amp;#64;&amp;quot;%&amp;#64; %&amp;#64;&amp;quot;, classDescription, NSStringFromCGRect(view.frame));
    else
        NSLog(&amp;#64;&amp;quot;%&amp;#64; %&amp;#64; %&amp;#64;&amp;quot;, label, classDescription, NSStringFromCGRect(view.frame));
    for (NSUInteger i = 0; i &amp;lt; [view.subviews count]; i++)
    {
        UIView *subView = [view.subviews objectAtIndex:i];
        NSString *newIndent = [[NSString alloc] initWithFormat:&amp;#64;&amp;quot;  %&amp;#64;&amp;quot;, indent];
        NSString *newLabel = [[NSString alloc] initWithFormat:&amp;#64;&amp;quot;%&amp;#64;%d:&amp;quot;, newIndent, i];
        dumpViews(subView, newLabel, newIndent);
        [newLabel release];
        [newIndent release];
    }
}

uinavigatorbar 只有一个子视图是imageview 是layer对象 index是0
&lt;/pre&gt;
</summary></entry><entry><title>android应用中实现drag listview</title><link href="http://xiangyuan.github.io/posts/2012/12/03/androidying-yong-zhong-shi-xian-drag-listview/" rel="alternate"></link><updated>2012-12-03T09:35:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-03:posts/2012/12/03/androidying-yong-zhong-shi-xian-drag-listview/</id><summary type="html">&lt;p&gt;一些应用在拖动一个列表项时会浮现一个小图片用于代表当前拖动的列表项&lt;/p&gt;
&lt;p&gt;核心代码如下。&lt;/p&gt;
&lt;pre class="literal-block"&gt;
//自定义ListView，准备改造成自己想要的ListView

//这样的好处是我们不仅可以直接使用ListView很多现成的稳定的方法，而且可以重写方法改写ListView的行为（利用的是java面向对象的继承特性，本人喜欢在任何代码中分析面向对象的特性、原则和模式）

public class DragListView extends ListView {
    private static final String TAG = DragListView.class.getSimpleName();
    /**
     * 被拖拽项的影像，其实就是一个ImageView
     * */
    private ImageView dragImageView;

    private int dragPointX;//手指拖动的位置坐标
    private int dragPointY;
    private int dragOffsetX;//拖动影像与手指拖动位置的偏移
    private int dragOffsetY;

    private int dragDownX;//手指开始拖拽的起始点x坐标

    private WindowManager windowManager;// windows窗口控制类

    private WindowManager.LayoutParams windowParams;// 用于控制拖拽项的显示的参数

    private DragListener mDragListener;

    public DragListView(Context context, AttributeSet attrs) {

        super(context, attrs);

        setOnItemLongClickListener(new OnItemLongClickListener() {
            &amp;#64;Override
            public boolean onItemLongClick(AdapterView&amp;lt;?&amp;gt; parent, View v,
                    int position, long id) {
                Log.e(TAG, &amp;quot;onItemLongClick&amp;quot;);
                // 设置Drawingcache为true，获得选中项的影像bm，就是后面我们拖动的哪个头像
                v.setDrawingCacheEnabled(true);
                Bitmap bm = Bitmap.createBitmap(v.getDrawingCache());

                startDrag(bm);
                return true;
            }
        });
    }

    &amp;#64;Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        // 捕获down事件
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            int x = (int) ev.getX();
            int y = (int) ev.getY();

            // 如果是无效位置(超出边界，分割线等位置)，返回
            if (getCount() &amp;lt; 1) {

                return super.onInterceptTouchEvent(ev);

            }

            if (mDragListener != null) {
                mDragListener.down(x, y);
            }

            ViewGroup itemView = (ViewGroup) getChildAt(0);

            if (itemView != null) {
                dragPointY = (int) (ev.getRawY() - (itemView.getHeight() / 2));
                dragOffsetY = (itemView.getHeight() / 2);
                dragOffsetX = (int) (itemView.getWidth() / 2);
                dragPointX = x + dragOffsetX;
                dragDownX = x;
            }

            return false;

        }

        return super.onInterceptTouchEvent(ev);

    }

    /**
     *
     * 准备拖动，初始化拖动项的图像
     *
     * &amp;#64;param bm
     *
     * &amp;#64;param y
     */
    public void startDrag(Bitmap bm) {
        // 释放影像，在准备影像的时候，防止影像没释放，每次都执行一下
        stopDrag();
        windowParams = new WindowManager.LayoutParams();
        // 从上到下计算y方向上的相对位置，
        windowParams.gravity = Gravity.TOP | Gravity.LEFT;
        windowParams.x = dragPointX;
        windowParams.y = dragPointY;
        windowParams.width = WindowManager.LayoutParams.WRAP_CONTENT;
        windowParams.height = WindowManager.LayoutParams.WRAP_CONTENT;

        LogEx.i(TAG, &amp;quot;x:--&amp;gt;&amp;quot; + windowParams.x + &amp;quot; y: &amp;quot; + windowParams.y);
        // 下面这些参数能够帮助准确定位到选中项点击位置，照抄即可
        windowParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE
                | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON
                | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;

        windowParams.format = PixelFormat.TRANSLUCENT;
        windowParams.windowAnimations = 0;

        // 把影像ImagView添加到当前视图中
        ImageView imageView = new ImageView(getContext());
        imageView.setImageBitmap(bm);
        windowManager = (WindowManager) getContext().getSystemService(&amp;quot;window&amp;quot;);
        windowManager.addView(imageView, windowParams);

        // 把影像ImageView引用到变量drawImageView，用于后续操作(拖动，释放等等)
        dragImageView = imageView;
    }

    /**
     *
     * 停止拖动，去除拖动项的头像
     */

    public void stopDrag() {
        if (dragImageView != null) {
            dragPointX = 0;
            dragOffsetX = 0;
            windowManager.removeView(dragImageView);
            dragImageView = null;
        }
    }


过客/ty  20:41:41
    /**
     *
     * 触摸事件
     */

    &amp;#64;Override
    public boolean onTouchEvent(MotionEvent ev) {
        // LogEx.v(TAG, &amp;quot;x: &amp;quot; + ev.getX() + &amp;quot; y: &amp;quot; + ev.getY());
        // 如果dragmageView为空，说明拦截事件中已经判定仅仅是点击，不是拖动，返回
        // 如果点击的是无效位置，返回，需要重新判断
        if (dragImageView != null) {
            int action = ev.getAction();
            int moveY = (int) ev.getY();
            int moveX = (int) ev.getX();

            switch (action) {
            case MotionEvent.ACTION_UP:
                // 释放拖动影像
                stopDrag();
                // 放下后，判断位置，实现相应的位置删除和插入
                onDrop(moveX, moveY);
                break;
            case MotionEvent.ACTION_MOVE:

                dragPointY = (int) ev.getRawY() - dragOffsetY;
                dragPointX = (int) moveX + dragOffsetX;
                // 拖动影像
                onDrag(moveY, moveX);
                break;
            default:
                break;
            }
            return true;
        }
        // 这个返回值能够实现selected的选中效果，如果返回true则无选中效果
        return super.onTouchEvent(ev);

    }

    /**
     *
     * 拖动执行，在Move方法中执行
     *
     * &amp;#64;param y
     */

    public void onDrag(int moveY, int moveX) {

        if (dragImageView != null) {
            windowParams.alpha = 0.8f;
            windowParams.y = dragPointY;
            windowParams.x = dragPointX;
            windowManager.updateViewLayout(dragImageView, windowParams);
        }

        if (mDragListener != null) {
            mDragListener.move(dragPointX, moveY);
        }


    }

    /**
     *
     * 拖动放下的时候
     *
     * &amp;#64;param y
     */

    public void onDrop(int x, int y) {
        if (mDragListener != null) {
            if (x &amp;lt; dragDownX - 30) {
                mDragListener.drop(dragPointX, y);
            } else {
                mDragListener.removeBg();
            }
        }

    }

    public void setPointView(DragListener dragListener) {
        this.mDragListener = dragListener;
    }

    public interface DragListener {
        void down(int x, int y);

        void drop(int x, int y);

        void move(int x, int y);

        void removeBg();
    }
}
&lt;/pre&gt;
</summary></entry><entry><title>python+vim 开发环境</title><link href="http://xiangyuan.github.io/posts/2012/12/03/python-vim/" rel="alternate"></link><updated>2012-12-03T09:25:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-03:posts/2012/12/03/python-vim/</id><summary type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Vim as a PHP IDE&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;This Vim configuration is meant to be used to make Vim act more like&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/python_vim.rst&lt;/tt&gt;, line 9)&lt;/p&gt;
Line block ends without a blank line.&lt;/div&gt;
&lt;p&gt;an IDE. I use it mostly under MacVIM, so some things may be weird in
different environments. For now, I'm just planning on using github to
make managing my VIM configuraiton more easy, especially with deploying
it to different environments. I'm not sure if I will make this a
community projects.&lt;/p&gt;
&lt;p&gt;I do use this configuration on Linux while running plain vim, and it
works fine for the most part.&lt;/p&gt;
&lt;p&gt;上面的一稿文章。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;2、python的安装pydiction&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;a class="reference external" href="https://github.com/fsouza/Pydiction.git"&gt;https://github.com/fsouza/Pydiction.git&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;3、c/c++编写ide安装&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;a class="reference external" href="https://github.com/vim-scripts/c.vim.git"&gt;https://github.com/vim-scripts/c.vim.git&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;4、安装cocoa的vim&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;a class="reference external" href="https://github.com/msanders/cocoa.vim.git"&gt;https://github.com/msanders/cocoa.vim.git&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;更新为python-mode插件&lt;/strong&gt;&lt;/p&gt;
</summary></entry><entry><title>python接收系统参数</title><link href="http://xiangyuan.github.io/posts/2012/12/03/pythonjie-shou-xi-tong-can-shu/" rel="alternate"></link><updated>2012-12-03T09:17:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-03:posts/2012/12/03/pythonjie-shou-xi-tong-can-shu/</id><summary type="html">&lt;p&gt;python接收系统参数时注意&lt;/p&gt;
&lt;p&gt;python接收系统参数时第0个参数是指当前指定的文件名&lt;/p&gt;
&lt;p&gt;而实际上的参数列表是从1开始的&lt;/p&gt;
</summary></entry><entry><title>文件下载时会用到的http协议设置</title><link href="http://xiangyuan.github.io/posts/2012/12/02/wen-jian-xia-zai-shi-hui-yong-dao-de-httpxie-yi-she-zhi/" rel="alternate"></link><updated>2012-12-02T15:00:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-02:posts/2012/12/02/wen-jian-xia-zai-shi-hui-yong-dao-de-httpxie-yi-she-zhi/</id><summary type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;http协议中的应答头 说明&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;1.Allow 服务器支持哪些请求方法（如GET、POST等）。&lt;/div&gt;
&lt;div class="line"&gt;2.Content-Encoding&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/http_protocol.rst&lt;/tt&gt;, line 8)&lt;/p&gt;
Line block ends without a blank line.&lt;/div&gt;
&lt;p&gt;文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档
的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE
4、IE
5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-
Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。
|  3.Content-Length
表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入
ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过
byteArrayStream.writeTo(response.getOutputStream()发送内容。
|  4.Content-Type
表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置
Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。
|  5.Date
当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。
|  6.Expires 应该在什么时候认为文档已经过期，从而不再缓存它？
|  7.Last-Modified
文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文
档才会返回，否则返回一个304（Not
Modified）状态。Last-Modified也可用setDateHeader方法来设置。
|  8.Location
表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。
|  9.Refresh
表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”,
“5; URL=http://host/path”)让浏览器读取指定的页面。
|  注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh”
CONTENT=”5;URL=http://host/path”＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的
HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。&lt;/p&gt;
&lt;p&gt;而上面提到的MIME类型(Multipurpose Internet Mail Extensions 简称MIME
多用途互联网络电子邮件格式的扩展):通常有application/msexcel
application/msword application/x-msdownload application/mspowerpoint
application/xml等.&lt;/p&gt;
</summary></entry><entry><title>android权限检查</title><link href="http://xiangyuan.github.io/posts/2012/12/02/androidquan-xian-jian-cha/" rel="alternate"></link><updated>2012-12-02T14:58:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-02:posts/2012/12/02/androidquan-xian-jian-cha/</id><summary type="html">&lt;p&gt;1、checkpermission部分写到服务端的是：&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;writeInterfaceToken --&amp;gt;&amp;gt; android.app.IActivityManager&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;writeString---&amp;gt; permission 字符串&lt;/div&gt;
&lt;div class="line"&gt;writeInt --&amp;gt;pid&lt;/div&gt;
&lt;div class="line"&gt;writeInt --&amp;gt;uid&lt;/div&gt;
&lt;div class="line"&gt;写过去的code是Check_permission_transcation&lt;/div&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/android_permission_check.rst&lt;/tt&gt;, line 10)&lt;/p&gt;
Line block ends without a blank line.&lt;/div&gt;
&lt;p&gt;2、现在我们可以读出interfacetoken的值,只是出现了两次android.app.IActivityManager字符串值
|  只要分别是哪一个值就可以读取相关的值(理论)&lt;/p&gt;
&lt;p&gt;3、下面做验证&lt;/p&gt;
&lt;p&gt;从一些错误信息如下来看code是53&lt;/p&gt;
&lt;pre class="literal-block"&gt;
PID: 5165, UID: 10046
D/android.app.IActivityManager
Writing exception to parcel
E/DatabaseUtils(2622): java.lang.SecurityException: Permission Denial: reading com.android.providers.contacts.ContactsProvider2 uri content://com.android.contacts/contacts from pid=5165, uid=10046 requires android.permission.READ_CONTACTS
E/DatabaseUtils(2622):      at android.content.ContentProvider$Transport.enforceReadPermission(ContentProvider.java:295)
E/DatabaseUtils(2622):      at android.content.ContentProvider$Transport.query(ContentProvider.java:177)
&lt;/pre&gt;
</summary></entry><entry><title>android源码下编译自有工程通用make模板</title><link href="http://xiangyuan.github.io/posts/2012/12/02/androidyuan-ma-xia-bian-yi-zi-you-gong-cheng-tong-yong-makemo-ban/" rel="alternate"></link><updated>2012-12-02T14:56:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-02:posts/2012/12/02/androidyuan-ma-xia-bian-yi-zi-you-gong-cheng-tong-yong-makemo-ban/</id><summary type="html">&lt;p&gt;android 源码下建立自有工程下编译&lt;/p&gt;
&lt;p&gt;1、source build/envsetup.sh&lt;/p&gt;
&lt;p&gt;下面列出一个通用makefile模板&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# This makefile supplies the rules for building a library of JNI code for

# use by our example of how to bundle a shared library with an APK.

LOCAL_PATH:= $(call my-dir)

tw_module_tags := eng debug

include $(CLEAR_VARS)

LOCAL_MODULE_TAGS := $(tw_module_tags)

# This is the target being built.
LOCAL_MODULE:= libmyhello

#the target platform
#TARGET_PLATFORM := android-4
# All of the source files that we will compile.
LOCAL_SRC_FILES:= \
com_wonder_MyJniAppActivity.h calllocal.c
#system lib to use log
#LOCAL_LDLIBS+= -L$(SYSROOT)/system/lib -llog
# All of the shared libraries we link against.
LOCAL_SHARED_LIBRARIES := \
liblog

# No static libraries.
LOCAL_STATIC_LIBRARIES :=
# Also need the JNI headers.
LOCAL_C_INCLUDES += \
$(JNI_H_INCLUDE)

LOCAL_ARM_MODE := arm
# No special compiler flags.
LOCAL_CFLAGS +=

# Don't prelink this library. For more efficient code, you may want
# to add this library to the prelink map and set this to true. However,
# it's difficult to do this for applications that are not supplied as
# part of a system image.

LOCAL_PRELINK_MODULE := false

include $(BUILD_SHARED_LIBRARY)
&lt;/pre&gt;
</summary></entry><entry><title>android iotcl</title><link href="http://xiangyuan.github.io/posts/2012/12/02/android-iotcl/" rel="alternate"></link><updated>2012-12-02T14:55:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-02:posts/2012/12/02/android-iotcl/</id><summary type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;1、注入进程的libbinder中的hook的ioctl方法&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;应该是在framewords/base/libs/binder IPCThreadState.cpp中&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;基中在talkWithDriver的发送方法里所调用的ioctl方法。&lt;/p&gt;
&lt;p&gt;还有比较重要的就是parcel&lt;/p&gt;
</summary></entry><entry><title>python打包ios ipa包</title><link href="http://xiangyuan.github.io/posts/2012/12/02/pythonda-bao-ios-ipabao/" rel="alternate"></link><updated>2012-12-02T13:00:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-02:posts/2012/12/02/pythonda-bao-ios-ipabao/</id><summary type="html">&lt;p&gt;我们知道在ios上生成的itunes包应该是一个ipa的后缀的包，而不是直接xcode生成的.app的包。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;ipa包的组成&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;其中有两项：itunes 所认识的一个图片名为iTunesArtwork&lt;/div&gt;
&lt;div class="line"&gt;第二个重要的是 .app的应用程序&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;其实生成ipa包很简单 就是通过 zip -r进行打包。&lt;/p&gt;
&lt;p&gt;1、方法一将就.app包直接拖到itunes就可&lt;/p&gt;
&lt;p&gt;但作为coder嘛 所以还是通过程序来吧。&lt;/p&gt;
&lt;p&gt;下面以python还达到此目的，原理如上面所讲的。&lt;/p&gt;
&lt;pre class="literal-block"&gt;
class package:
    def __init__(self,origin_path,output_path):
        self.origin_path = origin_path
        self.output_path = output_path
        homeDirectory = os.environ['HOME']
        #project_directory = homeDirectory.join([os.path.sep,origin_path])
        project_directory = homeDirectory + os.path.sep + origin_path
        self.project_directory = project_directory

    def get_current_path(self,path_name):
        '''Get the current path
        keywork arguments:
        path_name-- the path name

        return string
        '''
        return path_name;
    def exec_cmd(self,cmd):
        retCode = -1
        try:
            print cmd
            retCode = subprocess.check_call(cmd)
        except EnvironmentError:
            print 'command execute encounter some error'
        return retCode
    def get_app_name(self):
        if os.path.isdir(self.project_directory + os.path.sep + 'build/Release-iphoneos'):

            os.chdir(self.project_directory + &amp;quot;build/Release-iphoneos&amp;quot;)
            for fName in os.listdir(self.project_directory + os.path.sep + 'build/Release-iphoneos'):
                #(filename,fileextend) = fName.rsplit('.')
                pattern = re.compile(&amp;quot;.app$&amp;quot;)
                if pattern.search(fName):
                    (filename,fileextend) = fName.split('.')
                    self.filename = filename
                    print os.getcwd()
                    self.exec_cmd(['zip','-r',filename + '.ipa',fName])

        #print os.path.walk(self.project_directory + os.path.sep + 'build/Release-iphoneos')
&lt;/pre&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;全部代码请查看 github地址&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;a href="#id1"&gt;&lt;span class="problematic" id="id2"&gt;``&lt;/span&gt;&lt;/a&gt;_&lt;/div&gt;
&lt;div class="line"&gt;里面还有很多需要完善的地方。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="system-message" id="id1"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/python_package.rst&lt;/tt&gt;, line 65); &lt;em&gt;&lt;a href="#id2"&gt;backlink&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
Inline literal start-string without end-string.&lt;/div&gt;
&lt;!-- _: https://github.com/xiangyuan/iospackage --&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/python_package.rst&lt;/tt&gt;, line 68)&lt;/p&gt;
malformed hyperlink target.&lt;/div&gt;
</summary></entry><entry><title>ios Image裁剪成圆形的方法之二</title><link href="http://xiangyuan.github.io/posts/2012/12/02/ios-imagecai-jian-cheng-yuan-xing-de-fang-fa-zhi-er/" rel="alternate"></link><updated>2012-12-02T12:51:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-12-02:posts/2012/12/02/ios-imagecai-jian-cheng-yuan-xing-de-fang-fa-zhi-er/</id><summary type="html">&lt;p&gt;各种应用上面有很多圆形的图片显示。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;如下图&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;a class="reference external" href="http://kingiol.com/bl/wp-content/uploads/2012/12/Screenshot-2012.12.02-12.39.26.png"&gt;&lt;img alt="image0" src="http://kingiol.com/bl/wp-content/uploads/2012/12/Screenshot-2012.12.02-12.39.26-200x300.png" /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;我知道的实现方法有三种。&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;1、通过image mask来操作，需要添加mask目标图片。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;2、通过imageview的layer来操作&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;如下代码&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;pre class="literal-block"&gt;
UIImageView * imageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:&amp;#64;&amp;quot;oiuyfdsa.png&amp;quot;]];
imageView.frame = CGRectMake(20.f, 20.f, 100.f, 100.f);
imageView.layer.masksToBounds = YES;
imageView.layer.cornerRadius = 50;
&lt;/pre&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;a.这种方法需要添加QuarztCore框架才能操作&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;b.cornerradus的确定问题&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;3、能过代码对画布裁剪成圆形--》然后再将原始图像画出来--》&lt;/p&gt;
&lt;pre class="literal-block"&gt;
-(UIImage*) circleImage:(UIImage*) image withParam:(CGFloat) inset {
    UIGraphicsBeginImageContext(image.size);
    CGContextRef context = UIGraphicsGetCurrentContext();
    CGContextSetLineWidth(context, 2);
    CGContextSetStrokeColorWithColor(context, [UIColor redColor].CGColor);
    CGRect rect = CGRectMake(inset, inset, image.size.width - inset * 2.0f, image.size.height - inset * 2.0f);
    CGContextAddEllipseInRect(context, rect);
    CGContextClip(context);

    [image drawInRect:rect];
    CGContextAddEllipseInRect(context, rect);
    CGContextStrokePath(context);
    UIImage *newimg = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return newimg;
}
&lt;/pre&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;上面代码注意 如果裁剪后没有使用 CGContextAddEllipseInRect(context,&lt;/div&gt;
&lt;/div&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/ios_image_round_corner.rst&lt;/tt&gt;, line 50)&lt;/p&gt;
Line block ends without a blank line.&lt;/div&gt;
&lt;p&gt;rect);
|  CGContextStrokePath(context); 这条代码
就会引起背景为白色时看不出来任务效果。
|  这里是椭圆操作
|  圆操作你懂的。&lt;/p&gt;
</summary></entry><entry><title>navigator设置透明</title><link href="http://xiangyuan.github.io/posts/2012/06/26/navigatorshe-zhi-tou-ming/" rel="alternate"></link><updated>2012-06-26T15:48:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-06-26:posts/2012/06/26/navigatorshe-zhi-tou-ming/</id><summary type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;下面方面可以使得ios里面导航条变成透明的。&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;类似appflow的效果&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;pre class="literal-block"&gt;
[navigationController.navigationBar setBackgroundImage:[UIImage imageNamed:&amp;#64;&amp;quot;topBarBg&amp;#64;2x.png&amp;quot;] forBarMetrics:UIBarMetricsDefault];
       [navigationController.navigationBar setTranslucent:YES];
&lt;/pre&gt;
&lt;p&gt;顺便把我测试中的mask图像的代码也写出来&lt;/p&gt;
&lt;pre class="literal-block"&gt;
UIImage * origin = [UIImage imageNamed:&amp;#64;&amp;quot;topBarBg&amp;#64;2x.png&amp;quot;];
  CGImageRef mask = [UIImage imageNamed:&amp;#64;&amp;quot;mask.png&amp;quot;].CGImage;
  CGImageRef maskRef = CGImageMaskCreate(CGImageGetWidth(mask), CGImageGetHeight(mask), CGImageGetBitsPerComponent(mask), CGImageGetBitsPerPixel(mask), CGImageGetBytesPerRow(mask), CGImageGetDataProvider(mask), NULL, YES);
  CGImageRef target = CGImageCreateWithMask(origin.CGImage, maskRef);
  return [UIImage imageWithCGImage:target];
&lt;/pre&gt;
</summary></entry><entry><title>MKNetwork网络请求过程中onCompletion调用两次的问题</title><link href="http://xiangyuan.github.io/posts/2012/05/30/mknetworkwang-luo-qing-qiu-guo-cheng-zhong-oncompletiondiao-yong-liang-ci-de-wen-ti/" rel="alternate"></link><updated>2012-05-30T17:45:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-05-30:posts/2012/05/30/mknetworkwang-luo-qing-qiu-guo-cheng-zhong-oncompletiondiao-yong-liang-ci-de-wen-ti/</id><summary type="html">&lt;p&gt;MKNetwork在网络请求过程中，MKNetworkOperation操作同一个url请求（GET请求）时会调用两次onCompletion。&lt;/p&gt;
&lt;p&gt;这样会引起两次的数据问题。&lt;/p&gt;
&lt;p&gt;现在一种解决方法。&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if ([operation isCachedResponse]) {
        //cached data
        NSString *jonData = [[operation responseString] JSONString];//直接清除原理数据
        NSLog(&amp;#64;&amp;quot;Cache %&amp;#64;&amp;quot;,jonData);
        [operation cancel];
    } else {
        //if (cached == NO) {//追加数据
            //fresh data
            NSString *jonData = [[operation responseString] JSONString];
            NSLog(&amp;#64;&amp;quot;Server %&amp;#64;&amp;quot;,jonData);
       // }
    }
&lt;/pre&gt;
</summary></entry><entry><title>parallax视差视图的实现</title><link href="http://xiangyuan.github.io/posts/2012/05/03/parallaxshi-chai-shi-tu-de-shi-xian/" rel="alternate"></link><updated>2012-05-03T10:17:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-05-03:posts/2012/05/03/parallaxshi-chai-shi-tu-de-shi-xian/</id><summary type="html">&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/parallax.rst&lt;/tt&gt;, line 5)&lt;/p&gt;
Field list ends without a blank line; unexpected unindent.&lt;/div&gt;
&lt;p&gt;:category:ios&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;视差视图的点型样子如下图。&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;img alt="视差视图" src="https://a248.e.akamai.net/camo.github.com/216e26efb562153ce0135d92ae93da022eb385d3/687474703a2f2f692e696d67666c69702e636f6d2f357a35622e676966" /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;实现方式我的github&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;a class="reference external" href="https://github.com/xiangyuan/parallax"&gt;我的github&lt;/a&gt;&lt;/div&gt;
&lt;div class="line"&gt;国外一哥们的&lt;/div&gt;
&lt;div class="line"&gt;&lt;a class="reference external" href="https://github.com/modocache/MDCParallaxView"&gt;MDCParallaxView&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面的都存在一个共同的问题，那就是视差的背景图片是没有事件响应的。下一篇告诉怎么解决。&lt;/p&gt;
</summary></entry><entry><title>JWfolder列表展开时问题修正</title><link href="http://xiangyuan.github.io/posts/2012/05/03/jwfolderlie-biao-zhan-kai-shi-wen-ti-xiu-zheng/" rel="alternate"></link><updated>2012-05-03T09:32:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-05-03:posts/2012/05/03/jwfolderlie-biao-zhan-kai-shi-wen-ti-xiu-zheng/</id><summary type="html">&lt;p&gt;&lt;a href="#id1"&gt;&lt;span class="problematic" id="id2"&gt;``&lt;/span&gt;&lt;/a&gt;_&lt;/p&gt;
&lt;div class="system-message" id="id1"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/jwfolder.rst&lt;/tt&gt;, line 8); &lt;em&gt;&lt;a href="#id2"&gt;backlink&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
Inline literal start-string without end-string.&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;这是一个可展开示例&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;img alt="image0" src="https://a248.e.akamai.net/camo.github.com/ade2f6e0148967944bc32a363765972ff8467355/687474703a2f2f7777772e6170706a6f6e2e636f6d2f6173736574732f6769746875622f6a77666f6c646572735f717569636b776561746865722e706e67" /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;但在使用到tableview里面操作时却会出现 重叠问题&lt;/p&gt;
&lt;p&gt;解决办法&lt;/p&gt;
&lt;pre class="literal-block"&gt;
UITableViewCell * cell = [tableView cellForRowAtIndexPath:indexPath];
        CGFloat y = cell.frame.origin.y;
        CGFloat varY = abs(y - tableView.contentOffset.y);
        if (varY &amp;gt; 316.f) {
           CGPoint point =  CGPointMake(tableView.contentOffset.x, tableView.contentOffset.y + 80.f);
            [tableView setContentOffset:point animated:NO];
        }
        CGFloat y1 = cell.center.y;
        CGFloat offset = tableView.contentOffset.y;
        CGFloat deltaY = y1 - offset;
        if (deltaY &amp;lt; 156) {
            deltaY += 83.f;
            CGPoint openPoint = CGPointMake(0, deltaY); //arbitrary point
            JWFolders *folder = [JWFolders folder];
            folder.contentView = controller.view;
            folder.containerView = self.view;
            folder.position = openPoint;
            folder.direction = JWFoldersOpenDirectionDown;
            folder.transparentPane = NO;
            [folder open];
        } else {
            deltaY += 83.f;
            CGPoint openPoint = CGPointMake(0, deltaY);
            [JWFolders openFolderWithContentView:controller.view
                                        position:openPoint
                                   containerView:self.view
                                       openBlock:^(UIView *contentView, CFTimeInterval duration, CAMediaTimingFunction *timingFunction) {
                                           //perform custom animation here on contentView if you wish

                                           [controller changeData];

                                       }
                                      closeBlock:^(UIView *contentView, CFTimeInterval duration, CAMediaTimingFunction *timingFunction) {

                                      }
                                 completionBlock:^ {
                                     //the folder is closed and gone, lets do something cool!
                                 }
                                       direction:JWFoldersOpenDirectionUp
             ];
        }
&lt;/pre&gt;
&lt;!-- _: https://github.com/jwilling/JWFolders.git --&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/jwfolder.rst&lt;/tt&gt;, line 61)&lt;/p&gt;
malformed hyperlink target.&lt;/div&gt;
</summary></entry><entry><title>天气预报组件</title><link href="http://xiangyuan.github.io/posts/2012/02/29/tian-qi-yu-bao-zu-jian/" rel="alternate"></link><updated>2012-02-29T15:05:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-02-29:posts/2012/02/29/tian-qi-yu-bao-zu-jian/</id><summary type="html">&lt;p&gt;一个天气显示组件，显示城市地址，图片 温度 具体时间&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;如图&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;img alt="天气" src="https://raw.github.com/xiangyuan/weathElement/master/Screenshot.png" /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;项目地址：&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/xiangyuan/weathElement"&gt;项目地址&lt;/a&gt;&lt;/p&gt;
</summary></entry><entry><title>viewcontroller 生命周期</title><link href="http://xiangyuan.github.io/posts/2012/01/30/viewcontroller-sheng-ming-zhou-qi/" rel="alternate"></link><updated>2012-01-30T17:47:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2012-01-30:posts/2012/01/30/viewcontroller-sheng-ming-zhou-qi/</id><summary type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;init、loadView、viewDidLoad、viewDidUnload、dealloc的关系&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;init方法&lt;/div&gt;
&lt;div class="line"&gt;在init方法中实例化必要的对象（遵从LazyLoad思想）&lt;/div&gt;
&lt;div class="line"&gt;init方法中初始化ViewController本身&lt;/div&gt;
&lt;div class="line"&gt;loadView方法&lt;/div&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2012/viewcontroller_lifecircle.rst&lt;/tt&gt;, line 9)&lt;/p&gt;
Line block ends without a blank line.&lt;/div&gt;
&lt;p&gt;当view需要被展示而它却是nil时，viewController会调用该方法。不要直接调用该方法。
|  如果手工维护views，必须重写该方法
|  如果使用IB维护views，必须不能重写该方法
|  loadView和IB构建view
|  viewDidLoad方法
|  重写该方法以进一步定制view
|  在iPhone OS
3.0及之后的版本中，还应该重写viewDidUnload来释放对view的任何索引
|  viewDidLoad后调用数据Model
|  viewDidUnload方法
|  当系统内存吃紧的时候会调用该方法（注：viewController没有被dealloc）
|  内存吃紧时，在iPhone OS
3.0之前didReceiveMemoryWarning是释放无用内存的唯一方式，但是OS
3.0及以后viewDidUnload方法是更好的方式
|
在该方法中将所有IBOutlet（无论是property还是实例变量）置为nil（系统release
view时已经将其release掉了）
|
在该方法中释放其他与view有关的对象、其他在运行时创建（但非系统必须）的对象、在viewDidLoad中被创建的对象、缓存数据等
|  release对象后，将对象置为nil（IBOutlet只需要将其置为nil，系统release
view时已经将其release掉了）
|
一般认为viewDidUnload是viewDidLoad的镜像，因为当view被重新请求时，viewDidLoad还会重新被执行
|
viewDidUnload中被release的对象必须是很容易被重新创建的对象（比如在viewDidLoad或其他方法中创建的对象），不要release用户数据或其他很难被重新创建的对象
|  dealloc方法
|  viewDidUnload和dealloc方法没有关联，dealloc还是继续做它该做的事情
|  举例：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/*
 *The viewhierarchy forthis controller has been torn down. This usually happens inresponse tolow memory notifications.
 *All IBOutlets should be released bysetting their propertytonil inorder tofree upasmuch memory aspossible.
 *This isalso a good place torelease other variables thatcan be recreated when needed.
 */
-(void)viewDidUnload {
    self.startButton =nil;
    [setupViewController release];
    setupViewController =nil;
}
-(void)dealloc {
    [startButton release];
    [setupViewController release];
    [super dealloc];
}
&lt;/pre&gt;
&lt;p&gt;转自：&lt;a class="reference external" href="http://xyxdasnjss.iteye.com/blog/1563926"&gt;http://xyxdasnjss.iteye.com/blog/1563926&lt;/a&gt;&lt;/p&gt;
</summary></entry><entry><title>mac下php相关配置文件</title><link href="http://xiangyuan.github.io/posts/2011/11/16/macxia-phpxiang-guan-pei-zhi-wen-jian/" rel="alternate"></link><updated>2011-11-16T10:48:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2011-11-16:posts/2011/11/16/macxia-phpxiang-guan-pei-zhi-wen-jian/</id><summary type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;昨天偶尔想用php写一个发http请求来写一个api。&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;结果HttpRequest类找不到。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;找资料时就发现有提及php.ini这个文件，由于之前也没有接触过这些东西。&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo find / php.ini
&lt;/pre&gt;
&lt;p&gt;命令查找了一个居然没有这个文件。&lt;/p&gt;
&lt;pre class="literal-block"&gt;
php -i | less
&lt;/pre&gt;
&lt;p&gt;用上述命令查看下.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Configuration File (php.ini) Path   /etc
Loaded Configuration File   （none）
Scan this dir for additional .ini files (none)
Additional .ini files parsed    (none)
&lt;/pre&gt;
&lt;p&gt;发现这个文件需要自己却创建一下.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cp php.ini.default php.ini
&lt;/pre&gt;
&lt;p&gt;php.ini.default文件在/etc/目录下面，是一个默认的配置文件。需要把里面的display_error打开，否刚就不会出现错误信息在开发过程中。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;回到最开始的问题，类找不到需要添加扩展。&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;phpinfo里面就可以发现下面这一项。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;pre class="literal-block"&gt;
extension_dir   /usr/lib/php/extensions/no-debug-non-zts-20090626   /usr/lib/php/extensions/no-debug-non-zts-20090626
&lt;/pre&gt;
&lt;p&gt;只xdebug.so扩展，添添加扩展。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;在安装扩展时有一个命令pear&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;发现我的mac居然没有这个管理工具&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;pre class="literal-block"&gt;
/usr/lib/php/
&lt;/pre&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;在上面目录下面install-pear-nozlib.phar 这个文件&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;运行下面命令就可以安装成功了&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;pre class="literal-block"&gt;
php install-pear-nozlib.phar
&lt;/pre&gt;
</summary></entry><entry><title>oc消息转发</title><link href="http://xiangyuan.github.io/posts/2011/11/03/ocxiao-xi-zhuan-fa/" rel="alternate"></link><updated>2011-11-03T10:28:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2011-11-03:posts/2011/11/03/ocxiao-xi-zhuan-fa/</id><summary type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;消息转发流程&lt;/h2&gt;
&lt;p&gt;当向Objective-C对象发送一个消息，但runtime在当前类及父类中找不到此selector对应的方法时，消息转发(message
forwarding)流程开始启动。&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;动态方法解析(Dynamic Method Resolution或Lazy method resolution)&lt;/p&gt;
&lt;p&gt;向当前类(Class)发送&lt;a class="reference external" href="http://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/resolveInstanceMethod:"&gt;resolveInstanceMethod:&lt;/a&gt;(对于类方法则为`resolveClassMethod:&lt;a href="#id2"&gt;&lt;span class="problematic" id="id3"&gt;`&lt;/span&gt;&lt;/a&gt;_)消息，如果返回YES,则系统认为请求的方法已经加入到了，则会重新发送消息。&lt;/p&gt;
&lt;div class="system-message" id="id2"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2011/oc_message.rst&lt;/tt&gt;, line 16); &lt;em&gt;&lt;a href="#id3"&gt;backlink&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Inline interpreted text or phrase reference start-string without end-string.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;快速转发路径(Fast forwarding path)&lt;/p&gt;
&lt;p&gt;若果当前target实现了&lt;a class="reference external" href="http://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/forwardingTargetForSelector:"&gt;forwardingTargetForSelector:&lt;/a&gt;方法,则调用此方法。如果此方法返回除nil和self的其他对象，则向返回对象重新发送消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;慢速转发路径(Normal forwarding path)&lt;/p&gt;
&lt;p&gt;首先runtime发送&lt;a class="reference external" href="http://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/methodSignatureForSelector:"&gt;methodSignatureForSelector:&lt;/a&gt;消息查看Selector对应的方法签名，即参数与返回值的类型信息。如果有方法签名返回，runtime则根据方法签名创建描述该消息的&lt;a class="reference external" href="http://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSInvocation_Class/Reference/Reference.html"&gt;NSInvocation&lt;/a&gt;，向当前对象发送&lt;a class="reference external" href="http://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/forwardInvocation:"&gt;forwardInvocation:&lt;/a&gt;消息，以创建的NSInvocation对象作为参数；若methodSignatureForSelector:无方法签名返回，则向当前对象发送&lt;a class="reference external" href="http://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/doesNotRecognizeSelector:"&gt;doesNotRecognizeSelector:&lt;/a&gt;消息,程序抛出异常退出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</summary></entry><entry><title>mac下一个处理plist文件的工具</title><link href="http://xiangyuan.github.io/posts/2011/11/03/macxia-ge-chu-li-plistwen-jian-de-gong-ju/" rel="alternate"></link><updated>2011-11-03T09:18:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2011-11-03:posts/2011/11/03/macxia-ge-chu-li-plistwen-jian-de-gong-ju/</id><summary type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;mac下一个处理plist文件的工具位于&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;/usr/libexec/PlistBuddy 工具&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary></entry><entry><title>ios 发url请求时注意</title><link href="http://xiangyuan.github.io/posts/2011/10/02/ios-fa-urlqing-qiu-shi-zhu-yi/" rel="alternate"></link><updated>2011-10-02T17:18:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2011-10-02:posts/2011/10/02/ios-fa-urlqing-qiu-shi-zhu-yi/</id><summary type="html">&lt;p&gt;今天在做自动补全请求时出现下面错误&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Error Domain=NSURLErrorDomain Code=-1000 &amp;quot;bad URL&amp;quot;
&lt;/pre&gt;
&lt;p&gt;后来发现，是因为url地址里面需要将中文字符转换下&lt;/p&gt;
&lt;p&gt;得用下面方法处理&lt;/p&gt;
&lt;pre class="literal-block"&gt;
NSString *properlyEscapedURL = [url stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
&lt;/pre&gt;
&lt;p&gt;以此记录&lt;/p&gt;
</summary></entry><entry><title>linux多定时器实现</title><link href="http://xiangyuan.github.io/posts/2011/08/02/linuxduo-ding-shi-qi-shi-xian/" rel="alternate"></link><updated>2011-08-02T14:59:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2011-08-02:posts/2011/08/02/linuxduo-ding-shi-qi-shi-xian/</id><summary type="html">&lt;p&gt;这是一个小小的开源项目，实现linux上的多定时器，在我的博客里面也提过一篇关于定时器的文章。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;/p&gt;
&lt;p&gt;&lt;a href="#id1"&gt;&lt;span class="problematic" id="id2"&gt;``&lt;/span&gt;&lt;/a&gt;_&lt;/p&gt;
&lt;div class="system-message" id="id1"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2011/linux-timmer.rst&lt;/tt&gt;, line 11); &lt;em&gt;&lt;a href="#id2"&gt;backlink&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
Inline literal start-string without end-string.&lt;/div&gt;
&lt;!-- _: https://github.com/xiangyuan/multitimer%20 --&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;/Users/liyajie1209/coamee.com/myblog/content/blog/2011/linux-timmer.rst&lt;/tt&gt;, line 13)&lt;/p&gt;
malformed hyperlink target.&lt;/div&gt;
</summary></entry><entry><title>object c 去掉尾部符号</title><link href="http://xiangyuan.github.io/posts/2011/05/03/object-c-qu-diao-wei-bu-fu-hao/" rel="alternate"></link><updated>2011-05-03T09:27:00+08:00</updated><author><name>向远</name></author><id>tag:xiangyuan.github.io,2011-05-03:posts/2011/05/03/object-c-qu-diao-wei-bu-fu-hao/</id><summary type="html">&lt;pre class="literal-block"&gt;
NSString * str = &amp;#64;&amp;quot;今天你还，好吗&amp;#64;？￥＃￥&amp;quot;;
//    NSString *nStr = &amp;#64;&amp;quot;~`!&amp;#64;#$%^&amp;amp;*;:\&amp;quot;',.?&amp;quot;;
    NSMutableCharacterSet *set = [[NSMutableCharacterSet alloc] init];
   [set formUnionWithCharacterSet:[NSCharacterSet lowercaseLetterCharacterSet]];//小写字母
    NSLog(&amp;#64;&amp;quot;1 %&amp;#64;&amp;quot;,[str stringByTrimmingCharactersInSet:set]);
   [set formUnionWithCharacterSet:[NSCharacterSet uppercaseLetterCharacterSet]];//大写字母
    NSLog(&amp;#64;&amp;quot;2 %&amp;#64;&amp;quot;,[str stringByTrimmingCharactersInSet:set]);
   [set formUnionWithCharacterSet:[NSCharacterSet symbolCharacterSet]];//符号
     NSLog(&amp;#64;&amp;quot;3 %&amp;#64;&amp;quot;,[str stringByTrimmingCharactersInSet:set]);
    [set formUnionWithCharacterSet:[NSCharacterSet punctuationCharacterSet]];//标点
    NSLog(&amp;#64;&amp;quot;4 %&amp;#64;&amp;quot;,[str stringByTrimmingCharactersInSet:set]);
&lt;/pre&gt;
</summary></entry></feed>